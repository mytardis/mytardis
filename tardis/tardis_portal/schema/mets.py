# -*- coding: utf-8 -*-
#
# Generated Thu Mar 17 13:49:32 2011 by generateDS.py version 2.4b.
# Modified by Gerson Galang to support xsd:anys in xmlData
#

import sys
import getopt
import re as re_

from xml.etree import ElementTree
from xml.dom import minidom

etree_ = None
Verbose_import_ = False

(XMLParser_import_none, XMLParser_import_lxml,
 XMLParser_import_elementtree) = range(3)
XMLParser_import_library = None
try:

    # lxml

    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print 'running with lxml.etree'
except ImportError:
    try:

        # cElementTree from Python 2.5+

        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print 'running with cElementTree on Python 2.5+'
    except ImportError:
        try:

            # ElementTree from Python 2.5+

            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print 'running with ElementTree on Python 2.5+'
        except ImportError:
            try:

                # normal cElementTree install

                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print 'running with cElementTree'
            except ImportError:
                try:

                    # normal ElementTree install

                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = \
                        XMLParser_import_elementtree
                    if Verbose_import_:
                        print 'running with ElementTree'
                except ImportError:
                    raise ImportError('Failed to import ElementTree from any known place'
                            )


def parsexml_(*args, **kwargs):
    if XMLParser_import_library == XMLParser_import_lxml and 'parser' \
        not in kwargs:

        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.

        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc


#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):

        def gds_format_string(self, input_data, input_name=''):
            return input_data

        def gds_validate_string(
            self,
            input_data,
            node,
            input_name='',
            ):
            return input_data

        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data

        def gds_validate_integer(
            self,
            input_data,
            node,
            input_name='',
            ):
            return input_data

        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data

        def gds_validate_integer_list(
            self,
            input_data,
            node,
            input_name='',
            ):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node,
                            'Requires sequence of integers')
            return input_data

        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data

        def gds_validate_float(
            self,
            input_data,
            node,
            input_name='',
            ):
            return input_data

        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data

        def gds_validate_float_list(
            self,
            input_data,
            node,
            input_name='',
            ):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node,
                            'Requires sequence of floats')
            return input_data

        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data

        def gds_validate_double(
            self,
            input_data,
            node,
            input_name='',
            ):
            return input_data

        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data

        def gds_validate_double_list(
            self,
            input_data,
            node,
            input_name='',
            ):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node,
                            'Requires sequence of doubles')
            return input_data

        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data

        def gds_validate_boolean(
            self,
            input_data,
            node,
            input_name='',
            ):
            return input_data

        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data

        def gds_validate_boolean_list(
            self,
            input_data,
            node,
            input_name='',
            ):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0'):
                    raise_parse_error(node,
                            'Requires sequence of booleans ("true", "1", "false", "0")'
                            )
            return input_data

        def gds_str_lower(self, instring):
            return instring.lower()

        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path

        Tag_strip_pattern_ = re_.compile(r'\{.*\}')

        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
STRING_CLEANUP_PAT = re_.compile(r"[\n\r\s]+")

#
# Support/utility functions.
#


def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = isinstance(inStr, basestring) and inStr or '%s' % inStr
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = isinstance(inStr, basestring) and inStr or '%s' % inStr
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', '&quot;')
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


class GDSParseError(Exception):

    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag,
                node.sourceline)
    else:
        msg = '%s (element %s)' % (msg, node.tag)
    raise GDSParseError(msg)


class MixedContainer:

    # Constants for category:

    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3

    # Constants for content_type:

    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7

    def __init__(
        self,
        category,
        content_type,
        name,
        value,
        ):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value

    def getCategory(self):
        return self.category

    def getContenttype(self, content_type):
        return self.content_type

    def getValue(self):
        return self.value

    def getName(self):
        return self.name

    def export(
        self,
        outfile,
        level,
        name,
        namespace,
        ):
        if self.category == MixedContainer.CategoryText:

            # Prevent exporting empty content as empty lines.

            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:

                 # category == MixedContainer.CategoryComplex

            self.value.export(outfile, level, namespace, name)

    def exportSimple(
        self,
        outfile,
        level,
        name,
        ):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value,
                          self.name))
        elif self.content_type == MixedContainer.TypeInteger \
            or self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value,
                          self.name))
        elif self.content_type == MixedContainer.TypeFloat \
            or self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value,
                          self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value,
                          self.name))

    def exportLiteral(
        self,
        outfile,
        level,
        name,
        ):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                           % (self.category, self.content_type,
                          self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                           % (self.category, self.content_type,
                          self.name, self.value))
        else:

                 # category == MixedContainer.CategoryComplex

            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n'
                          % (self.category, self.content_type,
                          self.name))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):

    def __init__(
        self,
        name='',
        data_type='',
        container=0,
        ):
        self.name = name
        self.data_type = data_type
        self.container = container

    def set_name(self, name):
        self.name = name

    def get_name(self):
        return self.name

    def set_data_type(self, data_type):
        self.data_type = data_type

    def get_data_type_chain(self):
        return self.data_type

    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type

    def set_container(self, container):
        self.container = container

    def get_container(self):
        return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)


#
# Data representation classes.
#


class metsType(GeneratedsSuper):

    """metsType: Complex Type for METS Sections A METS document consists of
    seven possible subsidiary sections: metsHdr (METS document
    header), dmdSec (descriptive metadata section), amdSec
    (administrative metadata section), fileGrp (file inventory
    group), structLink (structural map linking), structMap
    (structural map) and behaviorSec (behaviors section). ID (ID/O):
    This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    OBJID (string/O): Is the primary identifier assigned to the METS
    object as a whole. Although this attribute is not required, it
    is strongly recommended. This identifier is used to tag the
    entire METS object to external systems, in contrast with the ID
    identifier. LABEL (string/O): Is a simple title string used to
    identify the object/entity being described in the METS document
    for the user. TYPE (string/O): Specifies the class or type of
    the object, e.g.: book, journal, stereograph, dataset, video,
    etc. PROFILE (string/O): Indicates to which of the registered
    profile(s) the METS document conforms. For additional
    information about PROFILES see Chapter 5 of the METS Primer."""

    subclass = None
    superclass = None

    def __init__(
        self,
        PROFILE=None,
        LABEL=None,
        TYPE=None,
        ID=None,
        OBJID=None,
        metsHdr=None,
        dmdSec=None,
        amdSec=None,
        fileSec=None,
        structMap=None,
        structLink=None,
        behaviorSec=None,
        ):
        self.PROFILE = _cast(None, PROFILE)
        self.LABEL = _cast(None, LABEL)
        self.TYPE = _cast(None, TYPE)
        self.ID = _cast(None, ID)
        self.OBJID = _cast(None, OBJID)
        self.metsHdr = metsHdr
        if dmdSec is None:
            self.dmdSec = []
        else:
            self.dmdSec = dmdSec
        if amdSec is None:
            self.amdSec = []
        else:
            self.amdSec = amdSec
        self.fileSec = fileSec
        if structMap is None:
            self.structMap = []
        else:
            self.structMap = structMap
        self.structLink = structLink
        if behaviorSec is None:
            self.behaviorSec = []
        else:
            self.behaviorSec = behaviorSec

    def factory(*args_, **kwargs_):
        if metsType.subclass:
            return metsType.subclass(*args_, **kwargs_)
        else:
            return metsType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_metsHdr(self):
        return self.metsHdr

    def set_metsHdr(self, metsHdr):
        self.metsHdr = metsHdr

    def get_dmdSec(self):
        return self.dmdSec

    def set_dmdSec(self, dmdSec):
        self.dmdSec = dmdSec

    def add_dmdSec(self, value):
        self.dmdSec.append(value)

    def insert_dmdSec(self, index, value):
        self.dmdSec[index] = value

    def get_amdSec(self):
        return self.amdSec

    def set_amdSec(self, amdSec):
        self.amdSec = amdSec

    def add_amdSec(self, value):
        self.amdSec.append(value)

    def insert_amdSec(self, index, value):
        self.amdSec[index] = value

    def get_fileSec(self):
        return self.fileSec

    def set_fileSec(self, fileSec):
        self.fileSec = fileSec

    def get_structMap(self):
        return self.structMap

    def set_structMap(self, structMap):
        self.structMap = structMap

    def add_structMap(self, value):
        self.structMap.append(value)

    def insert_structMap(self, index, value):
        self.structMap[index] = value

    def get_structLink(self):
        return self.structLink

    def set_structLink(self, structLink):
        self.structLink = structLink

    def get_behaviorSec(self):
        return self.behaviorSec

    def set_behaviorSec(self, behaviorSec):
        self.behaviorSec = behaviorSec

    def add_behaviorSec(self, value):
        self.behaviorSec.append(value)

    def insert_behaviorSec(self, index, value):
        self.behaviorSec[index] = value

    def get_PROFILE(self):
        return self.PROFILE

    def set_PROFILE(self, PROFILE):
        self.PROFILE = PROFILE

    def get_LABEL(self):
        return self.LABEL

    def set_LABEL(self, LABEL):
        self.LABEL = LABEL

    def get_TYPE(self):
        return self.TYPE

    def set_TYPE(self, TYPE):
        self.TYPE = TYPE

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def get_OBJID(self):
        return self.OBJID

    def set_OBJID(self, OBJID):
        self.OBJID = OBJID

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='metsType',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='metsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='metsType',
        ):
        if self.PROFILE is not None and 'PROFILE' \
            not in already_processed:
            already_processed.append('PROFILE')
            outfile.write(' PROFILE=%s'
                          % (self.gds_format_string(self.PROFILE.encode(ExternalEncoding),
                          input_name='PROFILE'), ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            outfile.write(' LABEL=%s'
                          % (self.gds_format_string(quote_attrib(self.LABEL).encode(ExternalEncoding),
                          input_name='LABEL'), ))
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            outfile.write(' TYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.TYPE).encode(ExternalEncoding),
                          input_name='TYPE'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))
        if self.OBJID is not None and 'OBJID' not in already_processed:
            already_processed.append('OBJID')
            outfile.write(' OBJID=%s'
                          % (self.gds_format_string(quote_attrib(self.OBJID).encode(ExternalEncoding),
                          input_name='OBJID'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='metsType',
        ):
        if self.metsHdr:
            self.metsHdr.export(outfile, level, namespace_,
                                name_='metsHdr')
        for dmdSec_ in self.dmdSec:
            dmdSec_.export(outfile, level, namespace_, name_='dmdSec')
        for amdSec_ in self.amdSec:
            amdSec_.export(outfile, level, namespace_, name_='amdSec')
        if self.fileSec:
            self.fileSec.export(outfile, level, namespace_,
                                name_='fileSec')
        for structMap_ in self.structMap:
            structMap_.export(outfile, level, namespace_,
                              name_='structMap')
        if self.structLink:
            self.structLink.export(outfile, level, namespace_,
                                   name_='structLink')
        for behaviorSec_ in self.behaviorSec:
            behaviorSec_.export(outfile, level, namespace_,
                                name_='behaviorSec')

    def hasContent_(self):
        if self.metsHdr is not None or self.dmdSec or self.amdSec \
            or self.fileSec is not None or self.structMap \
            or self.structLink is not None or self.behaviorSec:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='metsType',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.PROFILE is not None and 'PROFILE' \
            not in already_processed:
            already_processed.append('PROFILE')
            showIndent(outfile, level)
            outfile.write('PROFILE = "%s",\n' % (self.PROFILE, ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            showIndent(outfile, level)
            outfile.write('LABEL = "%s",\n' % (self.LABEL, ))
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            showIndent(outfile, level)
            outfile.write('TYPE = "%s",\n' % (self.TYPE, ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))
        if self.OBJID is not None and 'OBJID' not in already_processed:
            already_processed.append('OBJID')
            showIndent(outfile, level)
            outfile.write('OBJID = "%s",\n' % (self.OBJID, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        if self.metsHdr is not None:
            showIndent(outfile, level)
            outfile.write('metsHdr=model_.metsHdr(\n')
            self.metsHdr.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('dmdSec=[\n')
        level += 1
        for dmdSec_ in self.dmdSec:
            showIndent(outfile, level)
            outfile.write('model_.mdSecType(\n')
            dmdSec_.exportLiteral(outfile, level, name_='mdSecType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('amdSec=[\n')
        level += 1
        for amdSec_ in self.amdSec:
            showIndent(outfile, level)
            outfile.write('model_.amdSecType(\n')
            amdSec_.exportLiteral(outfile, level, name_='amdSecType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.fileSec is not None:
            showIndent(outfile, level)
            outfile.write('fileSec=model_.fileSec(\n')
            self.fileSec.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('structMap=[\n')
        level += 1
        for structMap_ in self.structMap:
            showIndent(outfile, level)
            outfile.write('model_.structMapType(\n')
            structMap_.exportLiteral(outfile, level,
                    name_='structMapType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.structLink is not None:
            showIndent(outfile, level)
            outfile.write('structLink=model_.structLink(\n')
            self.structLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('behaviorSec=[\n')
        level += 1
        for behaviorSec_ in self.behaviorSec:
            showIndent(outfile, level)
            outfile.write('model_.behaviorSecType(\n')
            behaviorSec_.exportLiteral(outfile, level,
                    name_='behaviorSecType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('PROFILE')
        if value is not None and 'PROFILE' not in already_processed:
            already_processed.append('PROFILE')
            self.PROFILE = value
        value = attrs.get('LABEL')
        if value is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            self.LABEL = value
        value = attrs.get('TYPE')
        if value is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            self.TYPE = value
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = attrs.get('OBJID')
        if value is not None and 'OBJID' not in already_processed:
            already_processed.append('OBJID')
            self.OBJID = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        if nodeName_ == 'metsHdr':
            obj_ = metsHdr.factory()
            obj_.build(child_)
            self.set_metsHdr(obj_)
        elif nodeName_ == 'dmdSec':
            obj_ = mdSecType.factory()
            obj_.build(child_)
            self.dmdSec.append(obj_)
        elif nodeName_ == 'amdSec':
            obj_ = amdSecType.factory()
            obj_.build(child_)
            self.amdSec.append(obj_)
        elif nodeName_ == 'fileSec':
            obj_ = fileSec.factory()
            obj_.build(child_)
            self.set_fileSec(obj_)
        elif nodeName_ == 'structMap':
            obj_ = structMapType.factory()
            obj_.build(child_)
            self.structMap.append(obj_)
        elif nodeName_ == 'structLink':
            obj_ = structLink.factory()
            obj_.build(child_)
            self.set_structLink(obj_)
        elif nodeName_ == 'behaviorSec':
            obj_ = behaviorSecType.factory()
            obj_.build(child_)
            self.behaviorSec.append(obj_)


# end class metsType


class metsHdr(GeneratedsSuper):

    """The mets header element <metsHdr> captures metadata about the METS
    document itself, not the digital object the METS document
    encodes. Although it records a more limited set of metadata, it
    is very similar in function and purpose to the headers employed
    in other schema such as the Text Encoding Initiative (TEI) or in
    the Encoded Archival Description (EAD). ID (ID/O): This
    attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    ADMID (IDREFS/O): Contains the ID attribute values of the
    <techMD>, <sourceMD>, <rightsMD> and/or <digiprovMD> elements
    within the <amdSec> of the METS document that contain
    administrative metadata pertaining to the METS document itself.
    For more information on using METS IDREFS and IDREF type
    attributes for internal linking, see Chapter 4 of the METS
    Primer. CREATEDATE (dateTime/O): Records the date/time the METS
    document was created. LASTMODDATE (dateTime/O): Is used to
    indicate the date/time the METS document was last modified.
    RECORDSTATUS (string/O): Specifies the status of the METS
    document. It is used for internal processing purposes."""

    subclass = None
    superclass = None

    def __init__(
        self,
        CREATEDATE=None,
        RECORDSTATUS=None,
        ADMID=None,
        LASTMODDATE=None,
        ID=None,
        agent=None,
        altRecordID=None,
        metsDocumentID=None,
        ):
        self.CREATEDATE = _cast(None, CREATEDATE)
        self.RECORDSTATUS = _cast(None, RECORDSTATUS)
        self.ADMID = _cast(None, ADMID)
        self.LASTMODDATE = _cast(None, LASTMODDATE)
        self.ID = _cast(None, ID)
        if agent is None:
            self.agent = []
        else:
            self.agent = agent
        if altRecordID is None:
            self.altRecordID = []
        else:
            self.altRecordID = altRecordID
        self.metsDocumentID = metsDocumentID

    def factory(*args_, **kwargs_):
        if metsHdr.subclass:
            return metsHdr.subclass(*args_, **kwargs_)
        else:
            return metsHdr(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_agent(self):
        return self.agent

    def set_agent(self, agent):
        self.agent = agent

    def add_agent(self, value):
        self.agent.append(value)

    def insert_agent(self, index, value):
        self.agent[index] = value

    def get_altRecordID(self):
        return self.altRecordID

    def set_altRecordID(self, altRecordID):
        self.altRecordID = altRecordID

    def add_altRecordID(self, value):
        self.altRecordID.append(value)

    def insert_altRecordID(self, index, value):
        self.altRecordID[index] = value

    def get_metsDocumentID(self):
        return self.metsDocumentID

    def set_metsDocumentID(self, metsDocumentID):
        self.metsDocumentID = metsDocumentID

    def get_CREATEDATE(self):
        return self.CREATEDATE

    def set_CREATEDATE(self, CREATEDATE):
        self.CREATEDATE = CREATEDATE

    def get_RECORDSTATUS(self):
        return self.RECORDSTATUS

    def set_RECORDSTATUS(self, RECORDSTATUS):
        self.RECORDSTATUS = RECORDSTATUS

    def get_ADMID(self):
        return self.ADMID

    def set_ADMID(self, ADMID):
        self.ADMID = ADMID

    def get_LASTMODDATE(self):
        return self.LASTMODDATE

    def set_LASTMODDATE(self, LASTMODDATE):
        self.LASTMODDATE = LASTMODDATE

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='metsHdr',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='metsHdr')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='metsHdr',
        ):
        if self.CREATEDATE is not None and 'CREATEDATE' \
            not in already_processed:
            already_processed.append('CREATEDATE')
            outfile.write(' CREATEDATE=%s'
                          % (self.gds_format_string(quote_attrib(self.CREATEDATE).encode(ExternalEncoding),
                          input_name='CREATEDATE'), ))
        if self.RECORDSTATUS is not None and 'RECORDSTATUS' \
            not in already_processed:
            already_processed.append('RECORDSTATUS')
            outfile.write(' RECORDSTATUS=%s'
                          % (self.gds_format_string(quote_attrib(self.RECORDSTATUS).encode(ExternalEncoding),
                          input_name='RECORDSTATUS'), ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            outfile.write(' ADMID=%s'
                          % (self.gds_format_string(quote_attrib(self.ADMID).encode(ExternalEncoding),
                          input_name='ADMID'), ))
        if self.LASTMODDATE is not None and 'LASTMODDATE' \
            not in already_processed:
            already_processed.append('LASTMODDATE')
            outfile.write(' LASTMODDATE=%s'
                          % (self.gds_format_string(quote_attrib(self.LASTMODDATE).encode(ExternalEncoding),
                          input_name='LASTMODDATE'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='metsHdr',
        ):
        for agent_ in self.agent:
            agent_.export(outfile, level, namespace_, name_='agent')
        for altRecordID_ in self.altRecordID:
            altRecordID_.export(outfile, level, namespace_,
                                name_='altRecordID')
        if self.metsDocumentID:
            self.metsDocumentID.export(outfile, level, namespace_,
                    name_='metsDocumentID')

    def hasContent_(self):
        if self.agent or self.altRecordID or self.metsDocumentID \
            is not None:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='metsHdr',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.CREATEDATE is not None and 'CREATEDATE' \
            not in already_processed:
            already_processed.append('CREATEDATE')
            showIndent(outfile, level)
            outfile.write('CREATEDATE = "%s",\n' % (self.CREATEDATE, ))
        if self.RECORDSTATUS is not None and 'RECORDSTATUS' \
            not in already_processed:
            already_processed.append('RECORDSTATUS')
            showIndent(outfile, level)
            outfile.write('RECORDSTATUS = "%s",\n'
                          % (self.RECORDSTATUS, ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            showIndent(outfile, level)
            outfile.write('ADMID = "%s",\n' % (self.ADMID, ))
        if self.LASTMODDATE is not None and 'LASTMODDATE' \
            not in already_processed:
            already_processed.append('LASTMODDATE')
            showIndent(outfile, level)
            outfile.write('LASTMODDATE = "%s",\n' % (self.LASTMODDATE,
                          ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        showIndent(outfile, level)
        outfile.write('agent=[\n')
        level += 1
        for agent_ in self.agent:
            showIndent(outfile, level)
            outfile.write('model_.agent(\n')
            agent_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('altRecordID=[\n')
        level += 1
        for altRecordID_ in self.altRecordID:
            showIndent(outfile, level)
            outfile.write('model_.altRecordID(\n')
            altRecordID_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.metsDocumentID is not None:
            showIndent(outfile, level)
            outfile.write('metsDocumentID=model_.metsDocumentID(\n')
            self.metsDocumentID.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('CREATEDATE')
        if value is not None and 'CREATEDATE' not in already_processed:
            already_processed.append('CREATEDATE')
            self.CREATEDATE = value
        value = attrs.get('RECORDSTATUS')
        if value is not None and 'RECORDSTATUS' \
            not in already_processed:
            already_processed.append('RECORDSTATUS')
            self.RECORDSTATUS = value
        value = attrs.get('ADMID')
        if value is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            self.ADMID = value
        value = attrs.get('LASTMODDATE')
        if value is not None and 'LASTMODDATE' not in already_processed:
            already_processed.append('LASTMODDATE')
            self.LASTMODDATE = value
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        if nodeName_ == 'agent':
            obj_ = agent.factory()
            obj_.build(child_)
            self.agent.append(obj_)
        elif nodeName_ == 'altRecordID':
            obj_ = altRecordID.factory()
            obj_.build(child_)
            self.altRecordID.append(obj_)
        elif nodeName_ == 'metsDocumentID':
            obj_ = metsDocumentID.factory()
            obj_.build(child_)
            self.set_metsDocumentID(obj_)


# end class metsHdr


class agent(GeneratedsSuper):

    """agent: The agent element <agent> provides for various parties and
    their roles with respect to the METS record to be documented. ID
    (ID/O): This attribute uniquely identifies the element within
    the METS document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    ROLE (string/R): Specifies the function of the agent with
    respect to the METS record. The allowed values are: CREATOR: The
    person(s) or institution(s) responsible for the METS document.
    EDITOR: The person(s) or institution(s) that prepares the
    metadata for encoding. ARCHIVIST: The person(s) or
    institution(s) responsible for the document/collection.
    PRESERVATION: The person(s) or institution(s) responsible for
    preservation functions. DISSEMINATOR: The person(s) or
    institution(s) responsible for dissemination functions.
    CUSTODIAN: The person(s) or institution(s) charged with the
    oversight of a document/collection. IPOWNER: Intellectual
    Property Owner: The person(s) or institution holding copyright,
    trade or service marks or other intellectual property rights for
    the object. OTHER: Use OTHER if none of the preceding values
    pertains and clarify the type and location specifier being used
    in the OTHERROLE attribute (see below). OTHERROLE (string/O):
    Denotes a role not contained in the allowed values set if OTHER
    is indicated in the ROLE attribute. TYPE (string/O): is used to
    specify the type of AGENT. It must be one of the following
    values: INDIVIDUAL: Use if an individual has served as the
    agent. ORGANIZATION: Use if an institution, corporate body,
    association, non-profit enterprise, government, religious body,
    etc. has served as the agent. OTHER: Use OTHER if none of the
    preceding values pertain and clarify the type of agent specifier
    being used in the OTHERTYPE attribute OTHERTYPE (string/O):
    Specifies the type of agent when the value OTHER is indicated in
    the TYPE attribute."""

    subclass = None
    superclass = None

    def __init__(
        self,
        TYPE=None,
        OTHERTYPE=None,
        ROLE=None,
        ID=None,
        OTHERROLE=None,
        name=None,
        note=None,
        ):
        self.TYPE = _cast(None, TYPE)
        self.OTHERTYPE = _cast(None, OTHERTYPE)
        self.ROLE = _cast(None, ROLE)
        self.ID = _cast(None, ID)
        self.OTHERROLE = _cast(None, OTHERROLE)
        self.name = name
        if note is None:
            self.note = []
        else:
            self.note = note

    def factory(*args_, **kwargs_):
        if agent.subclass:
            return agent.subclass(*args_, **kwargs_)
        else:
            return agent(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_name(self):
        return self.name

    def set_name(self, name):
        self.name = name

    def get_note(self):
        return self.note

    def set_note(self, note):
        self.note = note

    def add_note(self, value):
        self.note.append(value)

    def insert_note(self, index, value):
        self.note[index] = value

    def get_TYPE(self):
        return self.TYPE

    def set_TYPE(self, TYPE):
        self.TYPE = TYPE

    def get_OTHERTYPE(self):
        return self.OTHERTYPE

    def set_OTHERTYPE(self, OTHERTYPE):
        self.OTHERTYPE = OTHERTYPE

    def get_ROLE(self):
        return self.ROLE

    def set_ROLE(self, ROLE):
        self.ROLE = ROLE

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def get_OTHERROLE(self):
        return self.OTHERROLE

    def set_OTHERROLE(self, OTHERROLE):
        self.OTHERROLE = OTHERROLE

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='agent',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='agent')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='agent',
        ):
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            outfile.write(' TYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.TYPE).encode(ExternalEncoding),
                          input_name='TYPE'), ))
        if self.OTHERTYPE is not None and 'OTHERTYPE' \
            not in already_processed:
            already_processed.append('OTHERTYPE')
            outfile.write(' OTHERTYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.OTHERTYPE).encode(ExternalEncoding),
                          input_name='OTHERTYPE'), ))
        if self.ROLE is not None and 'ROLE' not in already_processed:
            already_processed.append('ROLE')
            outfile.write(' ROLE=%s'
                          % (self.gds_format_string(quote_attrib(self.ROLE).encode(ExternalEncoding),
                          input_name='ROLE'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))
        if self.OTHERROLE is not None and 'OTHERROLE' \
            not in already_processed:
            already_processed.append('OTHERROLE')
            outfile.write(' OTHERROLE=%s'
                          % (self.gds_format_string(quote_attrib(self.OTHERROLE).encode(ExternalEncoding),
                          input_name='OTHERROLE'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='agent',
        ):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('<%sname>%s</%sname>\n' % (namespace_,
                          self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding),
                          input_name='name'), namespace_))
        for note_ in self.note:
            showIndent(outfile, level)
            outfile.write('<%snote>%s</%snote>\n' % (namespace_,
                          self.gds_format_string(quote_xml(note_).encode(ExternalEncoding),
                          input_name='note'), namespace_))

    def hasContent_(self):
        if self.name is not None or self.note:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='agent',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            showIndent(outfile, level)
            outfile.write('TYPE = "%s",\n' % (self.TYPE, ))
        if self.OTHERTYPE is not None and 'OTHERTYPE' \
            not in already_processed:
            already_processed.append('OTHERTYPE')
            showIndent(outfile, level)
            outfile.write('OTHERTYPE = "%s",\n' % (self.OTHERTYPE, ))
        if self.ROLE is not None and 'ROLE' not in already_processed:
            already_processed.append('ROLE')
            showIndent(outfile, level)
            outfile.write('ROLE = "%s",\n' % (self.ROLE, ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))
        if self.OTHERROLE is not None and 'OTHERROLE' \
            not in already_processed:
            already_processed.append('OTHERROLE')
            showIndent(outfile, level)
            outfile.write('OTHERROLE = "%s",\n' % (self.OTHERROLE, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n'
                          % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('note=[\n')
        level += 1
        for note_ in self.note:
            showIndent(outfile, level)
            outfile.write('%s,\n'
                          % quote_python(note_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('TYPE')
        if value is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            self.TYPE = value
        value = attrs.get('OTHERTYPE')
        if value is not None and 'OTHERTYPE' not in already_processed:
            already_processed.append('OTHERTYPE')
            self.OTHERTYPE = value
        value = attrs.get('ROLE')
        if value is not None and 'ROLE' not in already_processed:
            already_processed.append('ROLE')
            self.ROLE = value
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = attrs.get('OTHERROLE')
        if value is not None and 'OTHERROLE' not in already_processed:
            already_processed.append('OTHERROLE')
            self.OTHERROLE = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'note':
            note_ = child_.text
            note_ = self.gds_validate_string(note_, node, 'note')
            self.note.append(note_)


# end class agent


class altRecordID(GeneratedsSuper):

    """The alternative record identifier element <altRecordID> allows one
    to use alternative record identifier values for the digital
    object represented by the METS document; the primary record
    identifier is stored in the OBJID attribute in the root <mets>
    element. ID (ID/O): This attribute uniquely identifies the
    element within the METS document, and would allow the element to
    be referenced unambiguously from another element or document via
    an IDREF or an XPTR. For more information on using ID attributes
    for internal and external linking see Chapter 4 of the METS
    Primer. TYPE (string/O): A description of the identifier type
    (e.g., OCLC record number, LCCN, etc.)."""

    subclass = None
    superclass = None

    def __init__(
        self,
        TYPE=None,
        ID=None,
        valueOf_=None,
        ):
        self.TYPE = _cast(None, TYPE)
        self.ID = _cast(None, ID)
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if altRecordID.subclass:
            return altRecordID.subclass(*args_, **kwargs_)
        else:
            return altRecordID(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_TYPE(self):
        return self.TYPE

    def set_TYPE(self, TYPE):
        self.TYPE = TYPE

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='altRecordID',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='altRecordID')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='altRecordID',
        ):
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            outfile.write(' TYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.TYPE).encode(ExternalEncoding),
                          input_name='TYPE'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='altRecordID',
        ):
        pass

    def hasContent_(self):
        if self.valueOf_:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='altRecordID',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_, ))

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            showIndent(outfile, level)
            outfile.write('TYPE = "%s",\n' % (self.TYPE, ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        pass

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('TYPE')
        if value is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            self.TYPE = value
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        pass


# end class altRecordID


class metsDocumentID(GeneratedsSuper):

    """The metsDocument identifier element <metsDocumentID> allows a unique
    identifier to be assigned to the METS document itself. This may
    be different from the OBJID attribute value in the root <mets>
    element, which uniquely identifies the entire digital object
    represented by the METS document. ID (ID/O): This attribute
    uniquely identifies the element within the METS document, and
    would allow the element to be referenced unambiguously from
    another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external
    linking see Chapter 4 of the METS Primer. TYPE (string/O): A
    description of the identifier type."""

    subclass = None
    superclass = None

    def __init__(
        self,
        TYPE=None,
        ID=None,
        valueOf_=None,
        ):
        self.TYPE = _cast(None, TYPE)
        self.ID = _cast(None, ID)
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if metsDocumentID.subclass:
            return metsDocumentID.subclass(*args_, **kwargs_)
        else:
            return metsDocumentID(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_TYPE(self):
        return self.TYPE

    def set_TYPE(self, TYPE):
        self.TYPE = TYPE

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='metsDocumentID',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='metsDocumentID')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='metsDocumentID',
        ):
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            outfile.write(' TYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.TYPE).encode(ExternalEncoding),
                          input_name='TYPE'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='metsDocumentID',
        ):
        pass

    def hasContent_(self):
        if self.valueOf_:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='metsDocumentID',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_, ))

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            showIndent(outfile, level)
            outfile.write('TYPE = "%s",\n' % (self.TYPE, ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        pass

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('TYPE')
        if value is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            self.TYPE = value
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        pass


# end class metsDocumentID


class fileSec(GeneratedsSuper):

    """The overall purpose of the content file section element <fileSec> is
    to provide an inventory of and the location for the content
    files that comprise the digital object being described in the
    METS document. ID (ID/O): This attribute uniquely identifies the
    element within the METS document, and would allow the element to
    be referenced unambiguously from another element or document via
    an IDREF or an XPTR. For more information on using ID attributes
    for internal and external linking see Chapter 4 of the METS
    Primer."""

    subclass = None
    superclass = None

    def __init__(self, ID=None, fileGrp=None):
        self.ID = _cast(None, ID)
        if fileGrp is None:
            self.fileGrp = []
        else:
            self.fileGrp = fileGrp

    def factory(*args_, **kwargs_):
        if fileSec.subclass:
            return fileSec.subclass(*args_, **kwargs_)
        else:
            return fileSec(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_fileGrp(self):
        return self.fileGrp

    def set_fileGrp(self, fileGrp):
        self.fileGrp = fileGrp

    def add_fileGrp(self, value):
        self.fileGrp.append(value)

    def insert_fileGrp(self, index, value):
        self.fileGrp[index] = value

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='fileSec',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='fileSec')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='fileSec',
        ):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='fileSec',
        ):
        for fileGrp_ in self.fileGrp:
            fileGrp_.export(outfile, level, namespace_, name_='fileGrp')

    def hasContent_(self):
        if self.fileGrp:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='fileSec',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        showIndent(outfile, level)
        outfile.write('fileGrp=[\n')
        level += 1
        for fileGrp_ in self.fileGrp:
            showIndent(outfile, level)
            outfile.write('model_.fileGrp(\n')
            fileGrp_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        if nodeName_ == 'fileGrp':
            obj_ = fileGrp.factory()
            obj_.build(child_)
            self.fileGrp.append(obj_)


# end class fileSec


class amdSecType(GeneratedsSuper):

    """amdSecType: Complex Type for Administrative Metadata Sections The
    administrative metadata section consists of four possible
    subsidiary sections: techMD (technical metadata for
    text/image/audio/video files), rightsMD (intellectual property
    rights metadata), sourceMD (analog/digital source metadata), and
    digiprovMD (digital provenance metadata, that is, the history of
    migrations/translations performed on a digital library object
    from it's original digital capture/encoding). ID (ID/O): This
    attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer."""

    subclass = None
    superclass = None

    def __init__(
        self,
        ID=None,
        techMD=None,
        rightsMD=None,
        sourceMD=None,
        digiprovMD=None,
        ):
        self.ID = _cast(None, ID)
        if techMD is None:
            self.techMD = []
        else:
            self.techMD = techMD
        if rightsMD is None:
            self.rightsMD = []
        else:
            self.rightsMD = rightsMD
        if sourceMD is None:
            self.sourceMD = []
        else:
            self.sourceMD = sourceMD
        if digiprovMD is None:
            self.digiprovMD = []
        else:
            self.digiprovMD = digiprovMD

    def factory(*args_, **kwargs_):
        if amdSecType.subclass:
            return amdSecType.subclass(*args_, **kwargs_)
        else:
            return amdSecType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_techMD(self):
        return self.techMD

    def set_techMD(self, techMD):
        self.techMD = techMD

    def add_techMD(self, value):
        self.techMD.append(value)

    def insert_techMD(self, index, value):
        self.techMD[index] = value

    def get_rightsMD(self):
        return self.rightsMD

    def set_rightsMD(self, rightsMD):
        self.rightsMD = rightsMD

    def add_rightsMD(self, value):
        self.rightsMD.append(value)

    def insert_rightsMD(self, index, value):
        self.rightsMD[index] = value

    def get_sourceMD(self):
        return self.sourceMD

    def set_sourceMD(self, sourceMD):
        self.sourceMD = sourceMD

    def add_sourceMD(self, value):
        self.sourceMD.append(value)

    def insert_sourceMD(self, index, value):
        self.sourceMD[index] = value

    def get_digiprovMD(self):
        return self.digiprovMD

    def set_digiprovMD(self, digiprovMD):
        self.digiprovMD = digiprovMD

    def add_digiprovMD(self, value):
        self.digiprovMD.append(value)

    def insert_digiprovMD(self, index, value):
        self.digiprovMD[index] = value

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='amdSecType',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='amdSecType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='amdSecType',
        ):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='amdSecType',
        ):
        for techMD_ in self.techMD:
            techMD_.export(outfile, level, namespace_, name_='techMD')
        for rightsMD_ in self.rightsMD:
            rightsMD_.export(outfile, level, namespace_,
                             name_='rightsMD')
        for sourceMD_ in self.sourceMD:
            sourceMD_.export(outfile, level, namespace_,
                             name_='sourceMD')
        for digiprovMD_ in self.digiprovMD:
            digiprovMD_.export(outfile, level, namespace_,
                               name_='digiprovMD')

    def hasContent_(self):
        if self.techMD or self.rightsMD or self.sourceMD \
            or self.digiprovMD:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='amdSecType',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        showIndent(outfile, level)
        outfile.write('techMD=[\n')
        level += 1
        for techMD_ in self.techMD:
            showIndent(outfile, level)
            outfile.write('model_.mdSecType(\n')
            techMD_.exportLiteral(outfile, level, name_='mdSecType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('rightsMD=[\n')
        level += 1
        for rightsMD_ in self.rightsMD:
            showIndent(outfile, level)
            outfile.write('model_.mdSecType(\n')
            rightsMD_.exportLiteral(outfile, level, name_='mdSecType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('sourceMD=[\n')
        level += 1
        for sourceMD_ in self.sourceMD:
            showIndent(outfile, level)
            outfile.write('model_.mdSecType(\n')
            sourceMD_.exportLiteral(outfile, level, name_='mdSecType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('digiprovMD=[\n')
        level += 1
        for digiprovMD_ in self.digiprovMD:
            showIndent(outfile, level)
            outfile.write('model_.mdSecType(\n')
            digiprovMD_.exportLiteral(outfile, level, name_='mdSecType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        if nodeName_ == 'techMD':
            obj_ = mdSecType.factory()
            obj_.build(child_)
            self.techMD.append(obj_)
        elif nodeName_ == 'rightsMD':
            obj_ = mdSecType.factory()
            obj_.build(child_)
            self.rightsMD.append(obj_)
        elif nodeName_ == 'sourceMD':
            obj_ = mdSecType.factory()
            obj_.build(child_)
            self.sourceMD.append(obj_)
        elif nodeName_ == 'digiprovMD':
            obj_ = mdSecType.factory()
            obj_.build(child_)
            self.digiprovMD.append(obj_)


# end class amdSecType


class fileGrpType(GeneratedsSuper):

    """fileGrpType: Complex Type for File Groups The file group is used to
    cluster all of the digital files composing a digital library
    object in a hierarchical arrangement (fileGrp is recursively
    defined to enable the creation of the hierarchy). Any file group
    may contain zero or more file elements. File elements in turn
    can contain one or more FLocat elements (a pointer to a file
    containing content for this object) and/or a FContent element
    (the contents of the file, in either XML or Base64 encoding). ID
    (ID/O): This attribute uniquely identifies the element within
    the METS document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    VERSDATE (dateTime/O): An optional dateTime attribute specifying
    the date this version/fileGrp of the digital object was created.
    ADMID (IDREF/O): Contains the ID attribute values of the
    <techMD>, <sourceMD>, <rightsMD> and/or <digiprovMD> elements
    within the <amdSec> of the METS document applicable to all of
    the files in a particular file group. For more information on
    using METS IDREFS and IDREF type attributes for internal
    linking, see Chapter 4 of the METS Primer. USE (string/O): A
    tagging attribute to indicate the intended use of files within
    this file group (e.g., master, reference, thumbnails for image
    files). A USE attribute can be expressed at the<fileGrp> level,
    the <file> level, the <FLocat> level and/or the <FContent>
    level. A USE attribute value at the <fileGrp> level should
    pertain to all of the files in the <fileGrp>. A USE attribute at
    the <file> level should pertain to all copies of the file as
    represented by subsidiary <FLocat> and/or <FContent> elements. A
    USE attribute at the <FLocat> or <FContent> level pertains to
    the particular copy of the file that is either referenced
    (<FLocat>) or wrapped (<FContent>)."""

    subclass = None
    superclass = None

    def __init__(
        self,
        VERSDATE=None,
        ADMID=None,
        ID=None,
        USE=None,
        fileGrp=None,
        file=None,
        ):
        self.VERSDATE = _cast(None, VERSDATE)
        self.ADMID = _cast(None, ADMID)
        self.ID = _cast(None, ID)
        self.USE = _cast(None, USE)
        if fileGrp is None:
            self.fileGrp = []
        else:
            self.fileGrp = fileGrp
        if file is None:
            self.file = []
        else:
            self.file = file

    def factory(*args_, **kwargs_):
        if fileGrpType.subclass:
            return fileGrpType.subclass(*args_, **kwargs_)
        else:
            return fileGrpType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_fileGrp(self):
        return self.fileGrp

    def set_fileGrp(self, fileGrp):
        self.fileGrp = fileGrp

    def add_fileGrp(self, value):
        self.fileGrp.append(value)

    def insert_fileGrp(self, index, value):
        self.fileGrp[index] = value

    def get_file(self):
        return self.file

    def set_file(self, file):
        self.file = file

    def add_file(self, value):
        self.file.append(value)

    def insert_file(self, index, value):
        self.file[index] = value

    def get_VERSDATE(self):
        return self.VERSDATE

    def set_VERSDATE(self, VERSDATE):
        self.VERSDATE = VERSDATE

    def get_ADMID(self):
        return self.ADMID

    def set_ADMID(self, ADMID):
        self.ADMID = ADMID

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def get_USE(self):
        return self.USE

    def set_USE(self, USE):
        self.USE = USE

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='fileGrpType',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='fileGrpType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='fileGrpType',
        ):
        if self.VERSDATE is not None and 'VERSDATE' \
            not in already_processed:
            already_processed.append('VERSDATE')
            outfile.write(' VERSDATE=%s'
                          % (self.gds_format_string(quote_attrib(self.VERSDATE).encode(ExternalEncoding),
                          input_name='VERSDATE'), ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            outfile.write(' ADMID=%s'
                          % (self.gds_format_string(quote_attrib(self.ADMID).encode(ExternalEncoding),
                          input_name='ADMID'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))
        if self.USE is not None and 'USE' not in already_processed:
            already_processed.append('USE')
            outfile.write(' USE=%s'
                          % (self.gds_format_string(quote_attrib(self.USE).encode(ExternalEncoding),
                          input_name='USE'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='fileGrpType',
        ):
        for fileGrp_ in self.fileGrp:
            fileGrp_.export(outfile, level, namespace_, name_='fileGrp')
        for file_ in self.file:
            file_.export(outfile, level, namespace_, name_='file')

    def hasContent_(self):
        if self.fileGrp or self.file:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='fileGrpType',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.VERSDATE is not None and 'VERSDATE' \
            not in already_processed:
            already_processed.append('VERSDATE')
            showIndent(outfile, level)
            outfile.write('VERSDATE = "%s",\n' % (self.VERSDATE, ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            showIndent(outfile, level)
            outfile.write('ADMID = "%s",\n' % (self.ADMID, ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))
        if self.USE is not None and 'USE' not in already_processed:
            already_processed.append('USE')
            showIndent(outfile, level)
            outfile.write('USE = "%s",\n' % (self.USE, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        showIndent(outfile, level)
        outfile.write('fileGrp=[\n')
        level += 1
        for fileGrp_ in self.fileGrp:
            showIndent(outfile, level)
            outfile.write('model_.fileGrpType(\n')
            fileGrp_.exportLiteral(outfile, level, name_='fileGrpType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('file=[\n')
        level += 1
        for file_ in self.file:
            showIndent(outfile, level)
            outfile.write('model_.fileType(\n')
            file_.exportLiteral(outfile, level, name_='fileType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('VERSDATE')
        if value is not None and 'VERSDATE' not in already_processed:
            already_processed.append('VERSDATE')
            self.VERSDATE = value
        value = attrs.get('ADMID')
        if value is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            self.ADMID = value
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = attrs.get('USE')
        if value is not None and 'USE' not in already_processed:
            already_processed.append('USE')
            self.USE = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        if nodeName_ == 'fileGrp':
            obj_ = fileGrpType.factory()
            obj_.build(child_)
            self.fileGrp.append(obj_)
        elif nodeName_ == 'file':
            obj_ = fileType.factory()
            obj_.build(child_)
            self.file.append(obj_)


# end class fileGrpType


class structMapType(GeneratedsSuper):

    """structMapType: Complex Type for Structural Maps The structural map
    (structMap) outlines a hierarchical structure for the original
    object being encoded, using a series of nested div elements. ID
    (ID/O): This attribute uniquely identifies the element within
    the METS document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    TYPE (string/O): Identifies the type of structure represented by
    the <structMap>. For example, a <structMap> that represented a
    purely logical or intellectual structure could be assigned a
    TYPE value of "logical" whereas a <structMap> that
    represented a purely physical structure could be assigned a TYPE
    value of "physical". However, the METS schema neither
    defines nor requires a common vocabulary for this attribute. A
    METS profile, however, may well constrain the values for the
    <structMap> TYPE. LABEL (string/O): Describes the <structMap> to
    viewers of the METS document. This would be useful primarily
    where more than one <structMap> is provided for a single object.
    A descriptive LABEL value, in that case, could clarify to users
    the purpose of each of the available structMaps."""

    subclass = None
    superclass = None

    def __init__(
        self,
        TYPE=None,
        ID=None,
        LABEL=None,
        div=None,
        ):
        self.TYPE = _cast(None, TYPE)
        self.ID = _cast(None, ID)
        self.LABEL = _cast(None, LABEL)
        self.div = div

    def factory(*args_, **kwargs_):
        if structMapType.subclass:
            return structMapType.subclass(*args_, **kwargs_)
        else:
            return structMapType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_div(self):
        return self.div

    def set_div(self, div):
        self.div = div

    def get_TYPE(self):
        return self.TYPE

    def set_TYPE(self, TYPE):
        self.TYPE = TYPE

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def get_LABEL(self):
        return self.LABEL

    def set_LABEL(self, LABEL):
        self.LABEL = LABEL

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='structMapType',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='structMapType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='structMapType',
        ):
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            outfile.write(' TYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.TYPE).encode(ExternalEncoding),
                          input_name='TYPE'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            outfile.write(' LABEL=%s'
                          % (self.gds_format_string(quote_attrib(self.LABEL).encode(ExternalEncoding),
                          input_name='LABEL'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='structMapType',
        ):
        if self.div:
            self.div.export(outfile, level, namespace_, name_='div')

    def hasContent_(self):
        if self.div is not None:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='structMapType',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            showIndent(outfile, level)
            outfile.write('TYPE = "%s",\n' % (self.TYPE, ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            showIndent(outfile, level)
            outfile.write('LABEL = "%s",\n' % (self.LABEL, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        if self.div is not None:
            showIndent(outfile, level)
            outfile.write('div=model_.divType(\n')
            self.div.exportLiteral(outfile, level, name_='div')
            showIndent(outfile, level)
            outfile.write('),\n')

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('TYPE')
        if value is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            self.TYPE = value
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = attrs.get('LABEL')
        if value is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            self.LABEL = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        if nodeName_ == 'div':
            obj_ = divType.factory()
            obj_.build(child_)
            self.set_div(obj_)


# end class structMapType


class divType(GeneratedsSuper):

    """divType: Complex Type for Divisions The METS standard represents a
    document structurally as a series of nested div elements, that
    is, as a hierarchy (e.g., a book, which is composed of chapters,
    which are composed of subchapters, which are composed of text).
    Every div node in the structural map hierarchy may be connected
    (via subsidiary mptr or fptr elements) to content files which
    represent that div's portion of the whole document. SPECIAL NOTE
    REGARDING DIV ATTRIBUTE VALUES: to clarify the differences
    between the ORDER, ORDERLABEL, and LABEL attributes for the
    <div> element, imagine a text with 10 roman numbered pages
    followed by 10 arabic numbered pages. Page iii would have an
    ORDER of "3", an ORDERLABEL of "iii" and a LABEL of "Page iii",
    while page 3 would have an ORDER of "13", an ORDERLABEL of "3"
    and a LABEL of "Page 3". ID (ID/O): This attribute uniquely
    identifies the element within the METS document, and would allow
    the element to be referenced unambiguously from another element
    or document via an IDREF or an XPTR. For more information on
    using ID attributes for internal and external linking see
    Chapter 4 of the METS Primer. ORDER (integer/O): A
    representation of the div's order among its siblings (e.g., its
    absolute, numeric sequence). For an example, and clarification
    of the distinction between ORDER and ORDERLABEL, see the
    description of the ORDERLABEL attribute. ORDERLABEL (string/O):
    A representation of the div's order among its siblings (e.g.,
    "xii"), or of any non-integer native numbering system. It is
    presumed that this value will still be machine actionable (e.g.,
    it would support 'go to page ___' function), and it should
    not be used as a replacement/substitute for the LABEL attribute.
    To understand the differences between ORDER, ORDERLABEL and
    LABEL, imagine a text with 10 roman numbered pages followed by
    10 arabic numbered pages. Page iii would have an ORDER of
    "3", an ORDERLABEL of "iii" and a LABEL of "Page
    iii", while page 3 would have an ORDER of "13", an
    ORDERLABEL of "3" and a LABEL of "Page 3". LABEL
    (string/O): An attribute used, for example, to identify a <div>
    to an end user viewing the document. Thus a hierarchical
    arrangement of the <div> LABEL values could provide a table of
    contents to the digital content represented by a METS document
    and facilitate the users' navigation of the digital object.
    Note that a <div> LABEL should be specific to its level in the
    structural map. In the case of a book with chapters, the book
    <div> LABEL should have the book title and the chapter <div>;
    LABELs should have the individual chapter titles, rather than
    having the chapter <div> LABELs combine both book title and
    chapter title . For further of the distinction between LABEL and
    ORDERLABEL see the description of the ORDERLABEL attribute.
    DMDID (IDREFS/O): Contains the ID attribute values identifying
    the <dmdSec>, elements in the METS document that contain or link
    to descriptive metadata pertaining to the structural division
    represented by the current <div> element. For more information
    on using METS IDREFS and IDREF type attributes for internal
    linking, see Chapter 4 of the METS Primer. ADMID (IDREFS/O):
    Contains the ID attribute values identifying the <rightsMD>,
    <sourceMD>, <techMD> and/or <digiprovMD> elements within the
    <amdSec> of the METS document that contain or link to
    administrative metadata pertaining to the structural division
    represented by the <div> element. Typically the <div> ADMID
    attribute would be used to identify the <rightsMD> element or
    elements that pertain to the <div>, but it could be used anytime
    there was a need to link a <div> with pertinent administrative
    metadata. For more information on using METS IDREFS and IDREF
    type attributes for internal linking, see Chapter 4 of the METS
    Primer. TYPE (string/O): An attribute that specifies the type of
    structural division that the <div> element represents. Possible
    <div> TYPE attribute values include: chapter, article, page,
    track, segment, section etc. METS places no constraints on the
    possible TYPE values. Suggestions for controlled vocabularies
    for TYPE may be found on the METS website. CONTENTIDS (URI/O):
    Content IDs for the content represented by the <div> (equivalent
    to DIDL DII or Digital Item Identifier, a unique external ID).
    xlink:label - an xlink label to be referred to by an smLink
    element"""

    subclass = None
    superclass = None

    def __init__(
        self,
        ADMID=None,
        TYPE=None,
        LABEL=None,
        DMDID=None,
        ORDERLABEL=None,
        CONTENTIDS=None,
        label=None,
        ORDER=None,
        ID=None,
        mptr=None,
        fptr=None,
        div=None,
        ):
        self.ADMID = _cast(None, ADMID)
        self.TYPE = _cast(None, TYPE)
        self.LABEL = _cast(None, LABEL)
        self.DMDID = _cast(None, DMDID)
        self.ORDERLABEL = _cast(None, ORDERLABEL)
        self.CONTENTIDS = _cast(None, CONTENTIDS)
        self.label = _cast(None, label)
        self.ORDER = _cast(int, ORDER)
        self.ID = _cast(None, ID)
        if mptr is None:
            self.mptr = []
        else:
            self.mptr = mptr
        if fptr is None:
            self.fptr = []
        else:
            self.fptr = fptr
        if div is None:
            self.div = []
        else:
            self.div = div

    def factory(*args_, **kwargs_):
        if divType.subclass:
            return divType.subclass(*args_, **kwargs_)
        else:
            return divType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_mptr(self):
        return self.mptr

    def set_mptr(self, mptr):
        self.mptr = mptr

    def add_mptr(self, value):
        self.mptr.append(value)

    def insert_mptr(self, index, value):
        self.mptr[index] = value

    def get_fptr(self):
        return self.fptr

    def set_fptr(self, fptr):
        self.fptr = fptr

    def add_fptr(self, value):
        self.fptr.append(value)

    def insert_fptr(self, index, value):
        self.fptr[index] = value

    def get_div(self):
        return self.div

    def set_div(self, div):
        self.div = div

    def add_div(self, value):
        self.div.append(value)

    def insert_div(self, index, value):
        self.div[index] = value

    def get_ADMID(self):
        return self.ADMID

    def set_ADMID(self, ADMID):
        self.ADMID = ADMID

    def get_TYPE(self):
        return self.TYPE

    def set_TYPE(self, TYPE):
        self.TYPE = TYPE

    def get_LABEL(self):
        return self.LABEL

    def set_LABEL(self, LABEL):
        self.LABEL = LABEL

    def get_DMDID(self):
        return self.DMDID

    def set_DMDID(self, DMDID):
        self.DMDID = DMDID

    def get_ORDERLABEL(self):
        return self.ORDERLABEL

    def set_ORDERLABEL(self, ORDERLABEL):
        self.ORDERLABEL = ORDERLABEL

    def get_CONTENTIDS(self):
        return self.CONTENTIDS

    def set_CONTENTIDS(self, CONTENTIDS):
        self.CONTENTIDS = CONTENTIDS

    def validate_URIs(self, value):

        # Validate type URIs, a restriction on xsd:anyURI.

        pass

    def get_label(self):
        return self.label

    def set_label(self, label):
        self.label = label

    def get_ORDER(self):
        return self.ORDER

    def set_ORDER(self, ORDER):
        self.ORDER = ORDER

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='divType',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='divType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='divType',
        ):
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            outfile.write(' ADMID=%s'
                          % (self.gds_format_string(quote_attrib(self.ADMID).encode(ExternalEncoding),
                          input_name='ADMID'), ))
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            outfile.write(' TYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.TYPE).encode(ExternalEncoding),
                          input_name='TYPE'), ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            outfile.write(' LABEL=%s'
                          % (self.gds_format_string(quote_attrib(self.LABEL).encode(ExternalEncoding),
                          input_name='LABEL'), ))
        if self.DMDID is not None and 'DMDID' not in already_processed:
            already_processed.append('DMDID')
            outfile.write(' DMDID=%s'
                          % (self.gds_format_string(quote_attrib(self.DMDID).encode(ExternalEncoding),
                          input_name='DMDID'), ))
        if self.ORDERLABEL is not None and 'ORDERLABEL' \
            not in already_processed:
            already_processed.append('ORDERLABEL')
            outfile.write(' ORDERLABEL=%s'
                          % (self.gds_format_string(quote_attrib(self.ORDERLABEL).encode(ExternalEncoding),
                          input_name='ORDERLABEL'), ))
        if self.CONTENTIDS is not None and 'CONTENTIDS' \
            not in already_processed:
            already_processed.append('CONTENTIDS')
            outfile.write(' CONTENTIDS=%s'
                          % (quote_attrib(self.CONTENTIDS), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            outfile.write(' label=%s'
                          % (self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding),
                          input_name='label'), ))
        if self.ORDER is not None and 'ORDER' not in already_processed:
            already_processed.append('ORDER')
            outfile.write(' ORDER="%s"'
                          % self.gds_format_integer(self.ORDER,
                          input_name='ORDER'))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='divType',
        ):
        for mptr_ in self.mptr:
            mptr_.export(outfile, level, namespace_, name_='mptr')
        for fptr_ in self.fptr:
            fptr_.export(outfile, level, namespace_, name_='fptr')
        for div_ in self.div:
            div_.export(outfile, level, namespace_, name_='div')

    def hasContent_(self):
        if self.mptr or self.fptr or self.div:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='divType',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            showIndent(outfile, level)
            outfile.write('ADMID = "%s",\n' % (self.ADMID, ))
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            showIndent(outfile, level)
            outfile.write('TYPE = "%s",\n' % (self.TYPE, ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            showIndent(outfile, level)
            outfile.write('LABEL = "%s",\n' % (self.LABEL, ))
        if self.DMDID is not None and 'DMDID' not in already_processed:
            already_processed.append('DMDID')
            showIndent(outfile, level)
            outfile.write('DMDID = "%s",\n' % (self.DMDID, ))
        if self.ORDERLABEL is not None and 'ORDERLABEL' \
            not in already_processed:
            already_processed.append('ORDERLABEL')
            showIndent(outfile, level)
            outfile.write('ORDERLABEL = "%s",\n' % (self.ORDERLABEL, ))
        if self.CONTENTIDS is not None and 'CONTENTIDS' \
            not in already_processed:
            already_processed.append('CONTENTIDS')
            showIndent(outfile, level)
            outfile.write('CONTENTIDS = "%s",\n' % (self.CONTENTIDS, ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            showIndent(outfile, level)
            outfile.write('label = "%s",\n' % (self.label, ))
        if self.ORDER is not None and 'ORDER' not in already_processed:
            already_processed.append('ORDER')
            showIndent(outfile, level)
            outfile.write('ORDER = %d,\n' % (self.ORDER, ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        showIndent(outfile, level)
        outfile.write('mptr=[\n')
        level += 1
        for mptr_ in self.mptr:
            showIndent(outfile, level)
            outfile.write('model_.mptr(\n')
            mptr_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('fptr=[\n')
        level += 1
        for fptr_ in self.fptr:
            showIndent(outfile, level)
            outfile.write('model_.fptr(\n')
            fptr_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('div=[\n')
        level += 1
        for div_ in self.div:
            showIndent(outfile, level)
            outfile.write('model_.divType(\n')
            div_.exportLiteral(outfile, level, name_='divType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('ADMID')
        if value is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            self.ADMID = value
        value = attrs.get('TYPE')
        if value is not None and 'TYPE' not in already_processed:
            already_processed.append('TYPE')
            self.TYPE = value
        value = attrs.get('LABEL')
        if value is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            self.LABEL = value
        value = attrs.get('DMDID')
        if value is not None and 'DMDID' not in already_processed:
            already_processed.append('DMDID')
            self.DMDID = value
        value = attrs.get('ORDERLABEL')
        if value is not None and 'ORDERLABEL' not in already_processed:
            already_processed.append('ORDERLABEL')
            self.ORDERLABEL = value
        value = attrs.get('CONTENTIDS')
        if value is not None and 'CONTENTIDS' not in already_processed:
            already_processed.append('CONTENTIDS')
            self.CONTENTIDS = value
            self.validate_URIs(self.CONTENTIDS)  # validate type URIs
        value = attrs.get('label')
        if value is not None and 'label' not in already_processed:
            already_processed.append('label')
            self.label = value
        value = attrs.get('ORDER')
        if value is not None and 'ORDER' not in already_processed:
            already_processed.append('ORDER')
            try:
                self.ORDER = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s'
                                  % exp)
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        if nodeName_ == 'mptr':
            obj_ = mptr.factory()
            obj_.build(child_)
            self.mptr.append(obj_)
        elif nodeName_ == 'fptr':
            obj_ = fptr.factory()
            obj_.build(child_)
            self.fptr.append(obj_)
        elif nodeName_ == 'div':
            obj_ = divType.factory()
            obj_.build(child_)
            self.div.append(obj_)


# end class divType


class mptr(GeneratedsSuper):

    """Like the <fptr> element, the METS pointer element <mptr> represents
    digital content that manifests its parent <div> element. Unlike
    the <fptr>, which either directly or indirectly points to
    content represented in the <fileSec> of the parent METS
    document, the <mptr> element points to content represented by an
    external METS document. Thus, this element allows multiple
    discrete and separate METS documents to be organized at a higher
    level by a separate METS document. For example, METS documents
    representing the individual issues in the series of a journal
    could be grouped together and organized by a higher level METS
    document that represents the entire journal series. Each of the
    <div> elements in the <structMap> of the METS document
    representing the journal series would point to a METS document
    representing an issue. It would do so via a child <mptr>
    element. Thus the <mptr> element gives METS users considerable
    flexibility in managing the depth of the <structMap> hierarchy
    of individual METS documents. The <mptr> element points to an
    external METS document by means of an xlink:href attribute and
    associated XLink attributes. ID (ID/O): This attribute uniquely
    identifies the element within the METS document, and would allow
    the element to be referenced unambiguously from another element
    or document via an IDREF or an XPTR. For more information on
    using ID attributes for internal and external linking see
    Chapter 4 of the METS Primer. CONTENTIDS (URI/O): Content IDs
    for the content represented by the <mptr> (equivalent to DIDL
    DII or Digital Item Identifier, a unique external ID)."""

    subclass = None
    superclass = None

    def __init__(
        self,
        arcrole=None,
        show=None,
        OTHERLOCTYPE=None,
        title=None,
        actuate=None,
        href=None,
        role=None,
        LOCTYPE=None,
        CONTENTIDS=None,
        type_=None,
        ID=None,
        valueOf_=None,
        ):
        self.arcrole = _cast(None, arcrole)
        self.show = _cast(None, show)
        self.OTHERLOCTYPE = _cast(None, OTHERLOCTYPE)
        self.title = _cast(None, title)
        self.actuate = _cast(None, actuate)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.LOCTYPE = _cast(None, LOCTYPE)
        self.CONTENTIDS = _cast(None, CONTENTIDS)
        self.type_ = _cast(None, type_)
        self.ID = _cast(None, ID)
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if mptr.subclass:
            return mptr.subclass(*args_, **kwargs_)
        else:
            return mptr(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_arcrole(self):
        return self.arcrole

    def set_arcrole(self, arcrole):
        self.arcrole = arcrole

    def get_show(self):
        return self.show

    def set_show(self, show):
        self.show = show

    def get_OTHERLOCTYPE(self):
        return self.OTHERLOCTYPE

    def set_OTHERLOCTYPE(self, OTHERLOCTYPE):
        self.OTHERLOCTYPE = OTHERLOCTYPE

    def get_title(self):
        return self.title

    def set_title(self, title):
        self.title = title

    def get_actuate(self):
        return self.actuate

    def set_actuate(self, actuate):
        self.actuate = actuate

    def get_href(self):
        return self.href

    def set_href(self, href):
        self.href = href

    def get_role(self):
        return self.role

    def set_role(self, role):
        self.role = role

    def get_LOCTYPE(self):
        return self.LOCTYPE

    def set_LOCTYPE(self, LOCTYPE):
        self.LOCTYPE = LOCTYPE

    def get_CONTENTIDS(self):
        return self.CONTENTIDS

    def set_CONTENTIDS(self, CONTENTIDS):
        self.CONTENTIDS = CONTENTIDS

    def validate_URIs(self, value):

        # Validate type URIs, a restriction on xsd:anyURI.

        pass

    def get_type(self):
        return self.type_

    def set_type(self, type_):
        self.type_ = type_

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='mptr',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='mptr')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='mptr',
        ):
        if self.arcrole is not None and 'arcrole' \
            not in already_processed:
            already_processed.append('arcrole')
            outfile.write(' arcrole=%s'
                          % (self.gds_format_string(quote_attrib(self.arcrole).encode(ExternalEncoding),
                          input_name='arcrole'), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            outfile.write(' show=%s'
                          % (self.gds_format_string(quote_attrib(self.show).encode(ExternalEncoding),
                          input_name='show'), ))
        if self.OTHERLOCTYPE is not None and 'OTHERLOCTYPE' \
            not in already_processed:
            already_processed.append('OTHERLOCTYPE')
            outfile.write(' OTHERLOCTYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.OTHERLOCTYPE).encode(ExternalEncoding),
                          input_name='OTHERLOCTYPE'), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            outfile.write(' title=%s'
                          % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding),
                          input_name='title'), ))
        if self.actuate is not None and 'actuate' \
            not in already_processed:
            already_processed.append('actuate')
            outfile.write(' actuate=%s'
                          % (self.gds_format_string(quote_attrib(self.actuate).encode(ExternalEncoding),
                          input_name='actuate'), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            outfile.write(' href=%s'
                          % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding),
                          input_name='href'), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            outfile.write(' role=%s'
                          % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding),
                          input_name='role'), ))
        if self.LOCTYPE is not None and 'LOCTYPE' \
            not in already_processed:
            already_processed.append('LOCTYPE')
            outfile.write(' LOCTYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.LOCTYPE).encode(ExternalEncoding),
                          input_name='LOCTYPE'), ))
        if self.CONTENTIDS is not None and 'CONTENTIDS' \
            not in already_processed:
            already_processed.append('CONTENTIDS')
            outfile.write(' CONTENTIDS=%s'
                          % (quote_attrib(self.CONTENTIDS), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='mptr',
        ):
        pass

    def hasContent_(self):
        if self.valueOf_:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='mptr',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_, ))

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.arcrole is not None and 'arcrole' \
            not in already_processed:
            already_processed.append('arcrole')
            showIndent(outfile, level)
            outfile.write('arcrole = "%s",\n' % (self.arcrole, ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            showIndent(outfile, level)
            outfile.write('show = "%s",\n' % (self.show, ))
        if self.OTHERLOCTYPE is not None and 'OTHERLOCTYPE' \
            not in already_processed:
            already_processed.append('OTHERLOCTYPE')
            showIndent(outfile, level)
            outfile.write('OTHERLOCTYPE = "%s",\n'
                          % (self.OTHERLOCTYPE, ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title, ))
        if self.actuate is not None and 'actuate' \
            not in already_processed:
            already_processed.append('actuate')
            showIndent(outfile, level)
            outfile.write('actuate = "%s",\n' % (self.actuate, ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href, ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            showIndent(outfile, level)
            outfile.write('role = "%s",\n' % (self.role, ))
        if self.LOCTYPE is not None and 'LOCTYPE' \
            not in already_processed:
            already_processed.append('LOCTYPE')
            showIndent(outfile, level)
            outfile.write('LOCTYPE = "%s",\n' % (self.LOCTYPE, ))
        if self.CONTENTIDS is not None and 'CONTENTIDS' \
            not in already_processed:
            already_processed.append('CONTENTIDS')
            showIndent(outfile, level)
            outfile.write('CONTENTIDS = "%s",\n' % (self.CONTENTIDS, ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_, ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        pass

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('arcrole')
        if value is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            self.arcrole = value
        value = attrs.get('show')
        if value is not None and 'show' not in already_processed:
            already_processed.append('show')
            self.show = value
        value = attrs.get('OTHERLOCTYPE')
        if value is not None and 'OTHERLOCTYPE' \
            not in already_processed:
            already_processed.append('OTHERLOCTYPE')
            self.OTHERLOCTYPE = value
        value = attrs.get('title')
        if value is not None and 'title' not in already_processed:
            already_processed.append('title')
            self.title = value
        value = attrs.get('actuate')
        if value is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            self.actuate = value
        value = attrs.get('href')
        if value is not None and 'href' not in already_processed:
            already_processed.append('href')
            self.href = value
        value = attrs.get('role')
        if value is not None and 'role' not in already_processed:
            already_processed.append('role')
            self.role = value
        value = attrs.get('LOCTYPE')
        if value is not None and 'LOCTYPE' not in already_processed:
            already_processed.append('LOCTYPE')
            self.LOCTYPE = value
        value = attrs.get('CONTENTIDS')
        if value is not None and 'CONTENTIDS' not in already_processed:
            already_processed.append('CONTENTIDS')
            self.CONTENTIDS = value
            self.validate_URIs(self.CONTENTIDS)  # validate type URIs
        value = attrs.get('type')
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        pass


# end class mptr


class fptr(GeneratedsSuper):

    """The <fptr> or file pointer element represents digital content that
    manifests its parent <div> element. The content represented by
    an <fptr> element must consist of integral files or parts of
    files that are represented by <file> elements in the <fileSec>.
    Via its FILEID attribute, an <fptr> may point directly to a
    single integral <file> element that manifests a structural
    division. However, an <fptr> element may also govern an <area>
    element, a <par>, or a <seq> which in turn would point to the
    relevant file or files. A child <area> element can point to part
    of a <file> that manifests a division, while the <par> and <seq>
    elements can point to multiple files or parts of files that
    together manifest a division. More than one <fptr> element can
    be associated with a <div> element. Typically sibling <fptr>
    elements represent alternative versions, or manifestations, of
    the same content ID (ID/O): This attribute uniquely identifies
    the element within the METS document, and would allow the
    element to be referenced unambiguously from another element or
    document via an IDREF or an XPTR. For more information on using
    ID attributes for internal and external linking see Chapter 4 of
    the METS Primer. FILEID (IDREF/O): An optional attribute that
    provides the XML ID identifying the <file> element that links to
    and/or contains the digital content represented by the <fptr>. A
    <fptr> element should only have a FILEID attribute value if it
    does not have a child <area>, <par> or <seq> element. If it has
    a child element, then the responsibility for pointing to the
    relevant content falls to this child element or its descendants.
    CONTENTIDS (URI/O): Content IDs for the content represented by
    the <fptr> (equivalent to DIDL DII or Digital Item Identifier, a
    unique external ID)."""

    subclass = None
    superclass = None

    def __init__(
        self,
        CONTENTIDS=None,
        ID=None,
        FILEID=None,
        par=None,
        seq=None,
        area=None,
        ):
        self.CONTENTIDS = _cast(None, CONTENTIDS)
        self.ID = _cast(None, ID)
        self.FILEID = _cast(None, FILEID)
        self.par = par
        self.seq = seq
        self.area = area

    def factory(*args_, **kwargs_):
        if fptr.subclass:
            return fptr.subclass(*args_, **kwargs_)
        else:
            return fptr(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_par(self):
        return self.par

    def set_par(self, par):
        self.par = par

    def get_seq(self):
        return self.seq

    def set_seq(self, seq):
        self.seq = seq

    def get_area(self):
        return self.area

    def set_area(self, area):
        self.area = area

    def get_CONTENTIDS(self):
        return self.CONTENTIDS

    def set_CONTENTIDS(self, CONTENTIDS):
        self.CONTENTIDS = CONTENTIDS

    def validate_URIs(self, value):

        # Validate type URIs, a restriction on xsd:anyURI.

        pass

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def get_FILEID(self):
        return self.FILEID

    def set_FILEID(self, FILEID):
        self.FILEID = FILEID

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='fptr',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='fptr')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='fptr',
        ):
        if self.CONTENTIDS is not None and 'CONTENTIDS' \
            not in already_processed:
            already_processed.append('CONTENTIDS')
            outfile.write(' CONTENTIDS=%s'
                          % (quote_attrib(self.CONTENTIDS), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))
        if self.FILEID is not None and 'FILEID' \
            not in already_processed:
            already_processed.append('FILEID')
            outfile.write(' FILEID=%s'
                          % (self.gds_format_string(quote_attrib(self.FILEID).encode(ExternalEncoding),
                          input_name='FILEID'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='fptr',
        ):
        if self.par:
            self.par.export(outfile, level, namespace_, name_='par')
        if self.seq:
            self.seq.export(outfile, level, namespace_, name_='seq')
        if self.area:
            self.area.export(outfile, level, namespace_, name_='area')

    def hasContent_(self):
        if self.par is not None or self.seq is not None or self.area \
            is not None:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='fptr',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.CONTENTIDS is not None and 'CONTENTIDS' \
            not in already_processed:
            already_processed.append('CONTENTIDS')
            showIndent(outfile, level)
            outfile.write('CONTENTIDS = "%s",\n' % (self.CONTENTIDS, ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))
        if self.FILEID is not None and 'FILEID' \
            not in already_processed:
            already_processed.append('FILEID')
            showIndent(outfile, level)
            outfile.write('FILEID = "%s",\n' % (self.FILEID, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        if self.par is not None:
            showIndent(outfile, level)
            outfile.write('par=model_.parType(\n')
            self.par.exportLiteral(outfile, level, name_='par')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.seq is not None:
            showIndent(outfile, level)
            outfile.write('seq=model_.seqType(\n')
            self.seq.exportLiteral(outfile, level, name_='seq')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.area is not None:
            showIndent(outfile, level)
            outfile.write('area=model_.areaType(\n')
            self.area.exportLiteral(outfile, level, name_='area')
            showIndent(outfile, level)
            outfile.write('),\n')

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('CONTENTIDS')
        if value is not None and 'CONTENTIDS' not in already_processed:
            already_processed.append('CONTENTIDS')
            self.CONTENTIDS = value
            self.validate_URIs(self.CONTENTIDS)  # validate type URIs
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = attrs.get('FILEID')
        if value is not None and 'FILEID' not in already_processed:
            already_processed.append('FILEID')
            self.FILEID = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        if nodeName_ == 'par':
            obj_ = parType.factory()
            obj_.build(child_)
            self.set_par(obj_)
        elif nodeName_ == 'seq':
            obj_ = seqType.factory()
            obj_.build(child_)
            self.set_seq(obj_)
        elif nodeName_ == 'area':
            obj_ = areaType.factory()
            obj_.build(child_)
            self.set_area(obj_)


# end class fptr


class parType(GeneratedsSuper):

    """parType: Complex Type for Parallel Files The <par> or parallel files
    element aggregates pointers to files, parts of files, and/or
    sequences of files or parts of files that must be played or
    displayed simultaneously to manifest a block of digital content
    represented by an <fptr> element. ID (ID/O): This attribute
    uniquely identifies the element within the METS document, and
    would allow the element to be referenced unambiguously from
    another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external
    linking see Chapter 4 of the METS Primer."""

    subclass = None
    superclass = None

    def __init__(
        self,
        ID=None,
        area=None,
        seq=None,
        ):
        self.ID = _cast(None, ID)
        if area is None:
            self.area = []
        else:
            self.area = area
        if seq is None:
            self.seq = []
        else:
            self.seq = seq

    def factory(*args_, **kwargs_):
        if parType.subclass:
            return parType.subclass(*args_, **kwargs_)
        else:
            return parType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_area(self):
        return self.area

    def set_area(self, area):
        self.area = area

    def add_area(self, value):
        self.area.append(value)

    def insert_area(self, index, value):
        self.area[index] = value

    def get_seq(self):
        return self.seq

    def set_seq(self, seq):
        self.seq = seq

    def add_seq(self, value):
        self.seq.append(value)

    def insert_seq(self, index, value):
        self.seq[index] = value

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='parType',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='parType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='parType',
        ):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='parType',
        ):
        for area_ in self.area:
            area_.export(outfile, level, namespace_, name_='area')
        for seq_ in self.seq:
            seq_.export(outfile, level, namespace_, name_='seq')

    def hasContent_(self):
        if self.area or self.seq:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='parType',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        showIndent(outfile, level)
        outfile.write('area=[\n')
        level += 1
        for area_ in self.area:
            showIndent(outfile, level)
            outfile.write('model_.areaType(\n')
            area_.exportLiteral(outfile, level, name_='areaType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('seq=[\n')
        level += 1
        for seq_ in self.seq:
            showIndent(outfile, level)
            outfile.write('model_.seqType(\n')
            seq_.exportLiteral(outfile, level, name_='seqType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        if nodeName_ == 'area':
            obj_ = areaType.factory()
            obj_.build(child_)
            self.area.append(obj_)
        elif nodeName_ == 'seq':
            obj_ = seqType.factory()
            obj_.build(child_)
            self.seq.append(obj_)


# end class parType


class seqType(GeneratedsSuper):

    """seqType: Complex Type for Sequences of Files The seq element should
    be used to link a div to a set of content files when those files
    should be played/displayed sequentially to deliver content to a
    user. Individual <area> subelements within the seq element
    provide the links to the files or portions thereof. ID (ID/O):
    This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer."""

    subclass = None
    superclass = None

    def __init__(
        self,
        ID=None,
        area=None,
        par=None,
        ):
        self.ID = _cast(None, ID)
        if area is None:
            self.area = []
        else:
            self.area = area
        if par is None:
            self.par = []
        else:
            self.par = par

    def factory(*args_, **kwargs_):
        if seqType.subclass:
            return seqType.subclass(*args_, **kwargs_)
        else:
            return seqType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_area(self):
        return self.area

    def set_area(self, area):
        self.area = area

    def add_area(self, value):
        self.area.append(value)

    def insert_area(self, index, value):
        self.area[index] = value

    def get_par(self):
        return self.par

    def set_par(self, par):
        self.par = par

    def add_par(self, value):
        self.par.append(value)

    def insert_par(self, index, value):
        self.par[index] = value

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='seqType',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='seqType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='seqType',
        ):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='seqType',
        ):
        for area_ in self.area:
            area_.export(outfile, level, namespace_, name_='area')
        for par_ in self.par:
            par_.export(outfile, level, namespace_, name_='par')

    def hasContent_(self):
        if self.area or self.par:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='seqType',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        showIndent(outfile, level)
        outfile.write('area=[\n')
        level += 1
        for area_ in self.area:
            showIndent(outfile, level)
            outfile.write('model_.areaType(\n')
            area_.exportLiteral(outfile, level, name_='areaType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('par=[\n')
        level += 1
        for par_ in self.par:
            showIndent(outfile, level)
            outfile.write('model_.parType(\n')
            par_.exportLiteral(outfile, level, name_='parType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        if nodeName_ == 'area':
            obj_ = areaType.factory()
            obj_.build(child_)
            self.area.append(obj_)
        elif nodeName_ == 'par':
            obj_ = parType.factory()
            obj_.build(child_)
            self.par.append(obj_)


# end class seqType


class areaType(GeneratedsSuper):

    """areaType: Complex Type for Area Linking The area element provides
    for more sophisticated linking between a div element and content
    files representing that div, be they text, image, audio, or
    video files. An area element can link a div to a point within a
    file, to a one-dimension segment of a file (e.g., text segment,
    image line, audio/video clip), or a two-dimensional section of a
    file (e.g, subsection of an image, or a subsection of the video
    display of a video file. The area element has no content; all
    information is recorded within its various attributes. ID
    (ID/O): This attribute uniquely identifies the element within
    the METS document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    FILEID (IDREF/R): An attribute which provides the XML ID value
    that identifies the <file> element in the <fileSec> that then
    points to and/or contains the digital content represented by the
    <area> element. It must contain an ID value represented in an ID
    attribute associated with a <file> element in the <fileSec>
    element in the same METS document. SHAPE (string/O): An
    attribute that can be used as in HTML to define the shape of the
    relevant area within the content file pointed to by the <area>
    element. Typically this would be used with image content (still
    image or video frame) when only a portion of an integal image
    map pertains. If SHAPE is specified then COORDS must also be
    present. SHAPE should be used in conjunction with COORDS in the
    manner defined for the shape and coords attributes on an HTML4
    <area> element. SHAPE must contain one of the following values:
    RECT CIRCLE POLY COORDS (string/O): Specifies the coordinates in
    an image map for the shape of the pertinent area as specified in
    the SHAPE attribute. While technically optional, SHAPE and
    COORDS must both appear together to define the relevant area of
    image content. COORDS should be used in conjunction with SHAPE
    in the manner defined for the COORDs and SHAPE attributes on an
    HTML4 <area> element. COORDS must be a comma delimited string of
    integer value pairs representing coordinates (plus radius in the
    case of CIRCLE) within an image map. Number of coordinates pairs
    depends on shape: RECT: x1, y1, x2, y2; CIRC: x1, y1; POLY: x1,
    y1, x2, y2, x3, y3 . . . BEGIN (string/O): An attribute that
    specifies the point in the content file where the relevant
    section of content begins. It can be used in conjunction with
    either the END attribute or the EXTENT attribute as a means of
    defining the relevant portion of the referenced file precisely.
    It can only be interpreted meaningfully in conjunction with the
    BETYPE or EXTTYPE, which specify the kind of beginning/ending
    point values or beginning/extent values that are being used. The
    BEGIN attribute can be used with or without a companion END or
    EXTENT element. In this case, the end of the content file is
    assumed to be the end point. END (string/O): An attribute that
    specifies the point in the content file where the relevant
    section of content ends. It can only be interpreted meaningfully
    in conjunction with the BETYPE, which specifies the kind of
    ending point values being used. Typically the END attribute
    would only appear in conjunction with a BEGIN element. BETYPE:
    Begin/End Type. BETYPE (string/O): An attribute that specifies
    the kind of BEGIN and/or END values that are being used. For
    example, if BYTE is specified, then the BEGIN and END point
    values represent the byte offsets into a file. If IDREF is
    specified, then the BEGIN element specifies the ID value that
    identifies the element in a structured text file where the
    relevant section of the file begins; and the END value (if
    present) would specify the ID value that identifies the element
    with which the relevant section of the file ends. Must be one of
    the following values: BYTE IDREF SMIL MIDI SMPTE-25 SMPTE-24
    SMPTE-DF30 SMPTE-NDF30 SMPTE-DF29.97 SMPTE-NDF29.97 TIME TCF
    XPTR EXTENT (string/O): An attribute that specifies the extent
    of the relevant section of the content file. Can only be
    interpreted meaningfully in conjunction with the EXTTYPE which
    specifies the kind of value that is being used. Typically the
    EXTENT attribute would only appear in conjunction with a BEGIN
    element and would not be used if the BEGIN point represents an
    IDREF. EXTTYPE (string/O): An attribute that specifies the kind
    of EXTENT values that are being used. For example if BYTE is
    specified then EXTENT would represent a byte count. If TIME is
    specified the EXTENT would represent a duration of time. EXTTYPE
    must be one of the following values: BYTE SMIL MIDI SMPTE-25
    SMPTE-24 SMPTE-DF30 SMPTE-NDF30 SMPTE-DF29.97 SMPTE-NDF29.97
    TIME TCF. ADMID (IDREFS/O): Contains the ID attribute values
    identifying the <rightsMD>, <sourceMD>, <techMD> and/or
    <digiprovMD> elements within the <amdSec> of the METS document
    that contain or link to administrative metadata pertaining to
    the content represented by the <area> element. Typically the
    <area> ADMID attribute would be used to identify the <rightsMD>
    element or elements that pertain to the <area>, but it could be
    used anytime there was a need to link an <area> with pertinent
    administrative metadata. For more information on using METS
    IDREFS and IDREF type attributes for internal linking, see
    Chapter 4 of the METS Primer CONTENTIDS (URI/O): Content IDs for
    the content represented by the <area> (equivalent to DIDL DII or
    Digital Item Identifier, a unique external ID)."""

    subclass = None
    superclass = None

    def __init__(
        self,
        BEGIN=None,
        END=None,
        BETYPE=None,
        SHAPE=None,
        COORDS=None,
        EXTENT=None,
        CONTENTIDS=None,
        ADMID=None,
        ID=None,
        EXTTYPE=None,
        FILEID=None,
        valueOf_=None,
        ):
        self.BEGIN = _cast(None, BEGIN)
        self.END = _cast(None, END)
        self.BETYPE = _cast(None, BETYPE)
        self.SHAPE = _cast(None, SHAPE)
        self.COORDS = _cast(None, COORDS)
        self.EXTENT = _cast(None, EXTENT)
        self.CONTENTIDS = _cast(None, CONTENTIDS)
        self.ADMID = _cast(None, ADMID)
        self.ID = _cast(None, ID)
        self.EXTTYPE = _cast(None, EXTTYPE)
        self.FILEID = _cast(None, FILEID)
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if areaType.subclass:
            return areaType.subclass(*args_, **kwargs_)
        else:
            return areaType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_BEGIN(self):
        return self.BEGIN

    def set_BEGIN(self, BEGIN):
        self.BEGIN = BEGIN

    def get_END(self):
        return self.END

    def set_END(self, END):
        self.END = END

    def get_BETYPE(self):
        return self.BETYPE

    def set_BETYPE(self, BETYPE):
        self.BETYPE = BETYPE

    def get_SHAPE(self):
        return self.SHAPE

    def set_SHAPE(self, SHAPE):
        self.SHAPE = SHAPE

    def get_COORDS(self):
        return self.COORDS

    def set_COORDS(self, COORDS):
        self.COORDS = COORDS

    def get_EXTENT(self):
        return self.EXTENT

    def set_EXTENT(self, EXTENT):
        self.EXTENT = EXTENT

    def get_CONTENTIDS(self):
        return self.CONTENTIDS

    def set_CONTENTIDS(self, CONTENTIDS):
        self.CONTENTIDS = CONTENTIDS

    def validate_URIs(self, value):

        # Validate type URIs, a restriction on xsd:anyURI.

        pass

    def get_ADMID(self):
        return self.ADMID

    def set_ADMID(self, ADMID):
        self.ADMID = ADMID

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def get_EXTTYPE(self):
        return self.EXTTYPE

    def set_EXTTYPE(self, EXTTYPE):
        self.EXTTYPE = EXTTYPE

    def get_FILEID(self):
        return self.FILEID

    def set_FILEID(self, FILEID):
        self.FILEID = FILEID

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='areaType',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='areaType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='areaType',
        ):
        if self.BEGIN is not None and 'BEGIN' not in already_processed:
            already_processed.append('BEGIN')
            outfile.write(' BEGIN=%s'
                          % (self.gds_format_string(quote_attrib(self.BEGIN).encode(ExternalEncoding),
                          input_name='BEGIN'), ))
        if self.END is not None and 'END' not in already_processed:
            already_processed.append('END')
            outfile.write(' END=%s'
                          % (self.gds_format_string(quote_attrib(self.END).encode(ExternalEncoding),
                          input_name='END'), ))
        if self.BETYPE is not None and 'BETYPE' \
            not in already_processed:
            already_processed.append('BETYPE')
            outfile.write(' BETYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.BETYPE).encode(ExternalEncoding),
                          input_name='BETYPE'), ))
        if self.SHAPE is not None and 'SHAPE' not in already_processed:
            already_processed.append('SHAPE')
            outfile.write(' SHAPE=%s'
                          % (self.gds_format_string(quote_attrib(self.SHAPE).encode(ExternalEncoding),
                          input_name='SHAPE'), ))
        if self.COORDS is not None and 'COORDS' \
            not in already_processed:
            already_processed.append('COORDS')
            outfile.write(' COORDS=%s'
                          % (self.gds_format_string(quote_attrib(self.COORDS).encode(ExternalEncoding),
                          input_name='COORDS'), ))
        if self.EXTENT is not None and 'EXTENT' \
            not in already_processed:
            already_processed.append('EXTENT')
            outfile.write(' EXTENT=%s'
                          % (self.gds_format_string(quote_attrib(self.EXTENT).encode(ExternalEncoding),
                          input_name='EXTENT'), ))
        if self.CONTENTIDS is not None and 'CONTENTIDS' \
            not in already_processed:
            already_processed.append('CONTENTIDS')
            outfile.write(' CONTENTIDS=%s'
                          % (quote_attrib(self.CONTENTIDS), ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            outfile.write(' ADMID=%s'
                          % (self.gds_format_string(quote_attrib(self.ADMID).encode(ExternalEncoding),
                          input_name='ADMID'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))
        if self.EXTTYPE is not None and 'EXTTYPE' \
            not in already_processed:
            already_processed.append('EXTTYPE')
            outfile.write(' EXTTYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.EXTTYPE).encode(ExternalEncoding),
                          input_name='EXTTYPE'), ))
        if self.FILEID is not None and 'FILEID' \
            not in already_processed:
            already_processed.append('FILEID')
            outfile.write(' FILEID=%s'
                          % (self.gds_format_string(quote_attrib(self.FILEID).encode(ExternalEncoding),
                          input_name='FILEID'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='areaType',
        ):
        pass

    def hasContent_(self):
        if self.valueOf_:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='areaType',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_, ))

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.BEGIN is not None and 'BEGIN' not in already_processed:
            already_processed.append('BEGIN')
            showIndent(outfile, level)
            outfile.write('BEGIN = "%s",\n' % (self.BEGIN, ))
        if self.END is not None and 'END' not in already_processed:
            already_processed.append('END')
            showIndent(outfile, level)
            outfile.write('END = "%s",\n' % (self.END, ))
        if self.BETYPE is not None and 'BETYPE' \
            not in already_processed:
            already_processed.append('BETYPE')
            showIndent(outfile, level)
            outfile.write('BETYPE = "%s",\n' % (self.BETYPE, ))
        if self.SHAPE is not None and 'SHAPE' not in already_processed:
            already_processed.append('SHAPE')
            showIndent(outfile, level)
            outfile.write('SHAPE = "%s",\n' % (self.SHAPE, ))
        if self.COORDS is not None and 'COORDS' \
            not in already_processed:
            already_processed.append('COORDS')
            showIndent(outfile, level)
            outfile.write('COORDS = "%s",\n' % (self.COORDS, ))
        if self.EXTENT is not None and 'EXTENT' \
            not in already_processed:
            already_processed.append('EXTENT')
            showIndent(outfile, level)
            outfile.write('EXTENT = "%s",\n' % (self.EXTENT, ))
        if self.CONTENTIDS is not None and 'CONTENTIDS' \
            not in already_processed:
            already_processed.append('CONTENTIDS')
            showIndent(outfile, level)
            outfile.write('CONTENTIDS = "%s",\n' % (self.CONTENTIDS, ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            showIndent(outfile, level)
            outfile.write('ADMID = "%s",\n' % (self.ADMID, ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))
        if self.EXTTYPE is not None and 'EXTTYPE' \
            not in already_processed:
            already_processed.append('EXTTYPE')
            showIndent(outfile, level)
            outfile.write('EXTTYPE = "%s",\n' % (self.EXTTYPE, ))
        if self.FILEID is not None and 'FILEID' \
            not in already_processed:
            already_processed.append('FILEID')
            showIndent(outfile, level)
            outfile.write('FILEID = "%s",\n' % (self.FILEID, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        pass

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('BEGIN')
        if value is not None and 'BEGIN' not in already_processed:
            already_processed.append('BEGIN')
            self.BEGIN = value
        value = attrs.get('END')
        if value is not None and 'END' not in already_processed:
            already_processed.append('END')
            self.END = value
        value = attrs.get('BETYPE')
        if value is not None and 'BETYPE' not in already_processed:
            already_processed.append('BETYPE')
            self.BETYPE = value
        value = attrs.get('SHAPE')
        if value is not None and 'SHAPE' not in already_processed:
            already_processed.append('SHAPE')
            self.SHAPE = value
        value = attrs.get('COORDS')
        if value is not None and 'COORDS' not in already_processed:
            already_processed.append('COORDS')
            self.COORDS = value
        value = attrs.get('EXTENT')
        if value is not None and 'EXTENT' not in already_processed:
            already_processed.append('EXTENT')
            self.EXTENT = value
        value = attrs.get('CONTENTIDS')
        if value is not None and 'CONTENTIDS' not in already_processed:
            already_processed.append('CONTENTIDS')
            self.CONTENTIDS = value
            self.validate_URIs(self.CONTENTIDS)  # validate type URIs
        value = attrs.get('ADMID')
        if value is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            self.ADMID = value
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = attrs.get('EXTTYPE')
        if value is not None and 'EXTTYPE' not in already_processed:
            already_processed.append('EXTTYPE')
            self.EXTTYPE = value
        value = attrs.get('FILEID')
        if value is not None and 'FILEID' not in already_processed:
            already_processed.append('FILEID')
            self.FILEID = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        pass


# end class areaType


class structLinkType(GeneratedsSuper):

    """structLinkType: Complex Type for Structural Map Linking The
    Structural Map Linking section allows for the specification of
    hyperlinks between different components of a METS structure
    delineated in a structural map. structLink contains a single,
    repeatable element, smLink. Each smLink element indicates a
    hyperlink between two nodes in the structMap. The structMap
    nodes recorded in smLink are identified using their XML ID
    attribute values. ID (ID/O): This attribute uniquely identifies
    the element within the METS document, and would allow the
    element to be referenced unambiguously from another element or
    document via an IDREF or an XPTR. For more information on using
    ID attributes for internal and external linking see Chapter 4 of
    the METS Primer."""

    subclass = None
    superclass = None

    def __init__(
        self,
        ID=None,
        smLink=None,
        smLinkGrp=None,
        ):
        self.ID = _cast(None, ID)
        if smLink is None:
            self.smLink = []
        else:
            self.smLink = smLink
        if smLinkGrp is None:
            self.smLinkGrp = []
        else:
            self.smLinkGrp = smLinkGrp

    def factory(*args_, **kwargs_):
        if structLinkType.subclass:
            return structLinkType.subclass(*args_, **kwargs_)
        else:
            return structLinkType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_smLink(self):
        return self.smLink

    def set_smLink(self, smLink):
        self.smLink = smLink

    def add_smLink(self, value):
        self.smLink.append(value)

    def insert_smLink(self, index, value):
        self.smLink[index] = value

    def get_smLinkGrp(self):
        return self.smLinkGrp

    def set_smLinkGrp(self, smLinkGrp):
        self.smLinkGrp = smLinkGrp

    def add_smLinkGrp(self, value):
        self.smLinkGrp.append(value)

    def insert_smLinkGrp(self, index, value):
        self.smLinkGrp[index] = value

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='structLinkType',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='structLinkType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='structLinkType',
        ):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='structLinkType',
        ):
        for smLink_ in self.smLink:
            smLink_.export(outfile, level, namespace_, name_='smLink')
        for smLinkGrp_ in self.smLinkGrp:
            smLinkGrp_.export(outfile, level, namespace_,
                              name_='smLinkGrp')

    def hasContent_(self):
        if self.smLink or self.smLinkGrp:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='structLinkType',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        showIndent(outfile, level)
        outfile.write('smLink=[\n')
        level += 1
        for smLink_ in self.smLink:
            showIndent(outfile, level)
            outfile.write('model_.smLink(\n')
            smLink_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('smLinkGrp=[\n')
        level += 1
        for smLinkGrp_ in self.smLinkGrp:
            showIndent(outfile, level)
            outfile.write('model_.smLinkGrp(\n')
            smLinkGrp_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        if nodeName_ == 'smLink':
            obj_ = smLink.factory()
            obj_.build(child_)
            self.smLink.append(obj_)
        elif nodeName_ == 'smLinkGrp':
            obj_ = smLinkGrp.factory()
            obj_.build(child_)
            self.smLinkGrp.append(obj_)


# end class structLinkType


class smLink(GeneratedsSuper):

    """The Structural Map Link element <smLink> identifies a hyperlink
    between two nodes in the structural map. You would use <smLink>,
    for instance, to note the existence of hypertext links between
    web pages, if you wished to record those links within METS.
    NOTE: <smLink> is an empty element. The location of the <smLink>
    element to which the <smLink> element is pointing MUST be stored
    in the xlink:href attribute. ID (ID/O): This attribute uniquely
    identifies the element within the METS document, and would allow
    the element to be referenced unambiguously from another element
    or document via an IDREF or an XPTR. For more information on
    using ID attributes for internal and external linking see
    Chapter 4 of the METS Primer. xlink:arcrole - the role of the
    link, as per the xlink specification. See
    http://www.w3.org/TR/xlink/ xlink:title - a title for the link
    (if needed), as per the xlink specification. See
    http://www.w3.org/TR/xlink/ xlink:show - see the xlink
    specification at http://www.w3.org/TR/xlink/ xlink:actuate - see
    the xlink specification at http://www.w3.org/TR/xlink/ xlink:to
    - the value of the label for the element in the structMap you
    are linking to. xlink:from - the value of the label for the
    element in the structMap you are linking from."""

    subclass = None
    superclass = None

    def __init__(
        self,
        fromxx=None,
        show=None,
        title=None,
        actuate=None,
        to=None,
        arcrole=None,
        ID=None,
        valueOf_=None,
        ):
        self.fromxx = _cast(None, fromxx)
        self.show = _cast(None, show)
        self.title = _cast(None, title)
        self.actuate = _cast(None, actuate)
        self.to = _cast(None, to)
        self.arcrole = _cast(None, arcrole)
        self.ID = _cast(None, ID)
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if smLink.subclass:
            return smLink.subclass(*args_, **kwargs_)
        else:
            return smLink(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_from(self):
        return self.fromxx

    def set_from(self, fromxx):
        self.fromxx = fromxx

    def get_show(self):
        return self.show

    def set_show(self, show):
        self.show = show

    def get_title(self):
        return self.title

    def set_title(self, title):
        self.title = title

    def get_actuate(self):
        return self.actuate

    def set_actuate(self, actuate):
        self.actuate = actuate

    def get_to(self):
        return self.to

    def set_to(self, to):
        self.to = to

    def get_arcrole(self):
        return self.arcrole

    def set_arcrole(self, arcrole):
        self.arcrole = arcrole

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='smLink',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='smLink')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='smLink',
        ):
        if self.fromxx is not None and 'fromxx' \
            not in already_processed:
            already_processed.append('fromxx')
            outfile.write(' from=%s'
                          % (self.gds_format_string(quote_attrib(self.fromxx).encode(ExternalEncoding),
                          input_name='from'), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            outfile.write(' show=%s'
                          % (self.gds_format_string(quote_attrib(self.show).encode(ExternalEncoding),
                          input_name='show'), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            outfile.write(' title=%s'
                          % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding),
                          input_name='title'), ))
        if self.actuate is not None and 'actuate' \
            not in already_processed:
            already_processed.append('actuate')
            outfile.write(' actuate=%s'
                          % (self.gds_format_string(quote_attrib(self.actuate).encode(ExternalEncoding),
                          input_name='actuate'), ))
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            outfile.write(' to=%s'
                          % (self.gds_format_string(quote_attrib(self.to).encode(ExternalEncoding),
                          input_name='to'), ))
        if self.arcrole is not None and 'arcrole' \
            not in already_processed:
            already_processed.append('arcrole')
            outfile.write(' arcrole=%s'
                          % (self.gds_format_string(quote_attrib(self.arcrole).encode(ExternalEncoding),
                          input_name='arcrole'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='smLink',
        ):
        pass

    def hasContent_(self):
        if self.valueOf_:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='smLink',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_, ))

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.fromxx is not None and 'fromxx' \
            not in already_processed:
            already_processed.append('fromxx')
            showIndent(outfile, level)
            outfile.write('fromxx = "%s",\n' % (self.fromxx, ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            showIndent(outfile, level)
            outfile.write('show = "%s",\n' % (self.show, ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title, ))
        if self.actuate is not None and 'actuate' \
            not in already_processed:
            already_processed.append('actuate')
            showIndent(outfile, level)
            outfile.write('actuate = "%s",\n' % (self.actuate, ))
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            showIndent(outfile, level)
            outfile.write('to = "%s",\n' % (self.to, ))
        if self.arcrole is not None and 'arcrole' \
            not in already_processed:
            already_processed.append('arcrole')
            showIndent(outfile, level)
            outfile.write('arcrole = "%s",\n' % (self.arcrole, ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        pass

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('from')
        if value is not None and 'from' not in already_processed:
            already_processed.append('from')
            self.fromxx = value
        value = attrs.get('show')
        if value is not None and 'show' not in already_processed:
            already_processed.append('show')
            self.show = value
        value = attrs.get('title')
        if value is not None and 'title' not in already_processed:
            already_processed.append('title')
            self.title = value
        value = attrs.get('actuate')
        if value is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            self.actuate = value
        value = attrs.get('to')
        if value is not None and 'to' not in already_processed:
            already_processed.append('to')
            self.to = value
        value = attrs.get('arcrole')
        if value is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            self.arcrole = value
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        pass


# end class smLink


class smLinkGrp(GeneratedsSuper):

    """The structMap link group element <smLinkGrp> provides an
    implementation of xlink:extendLink, and provides xlink compliant
    mechanisms for establishing xlink:arcLink type links between 2
    or more <div> elements in <structMap> element(s) occurring
    within the same METS document or different METS documents. The
    smLinkGrp could be used as an alternative to the <smLink>
    element to establish a one-to-one link between <div> elements in
    the same METS document in a fully xlink compliant manner.
    However, it can also be used to establish one-to-many or many-
    to-many links between <div> elements. For example, if a METS
    document contains two <structMap> elements, one of which
    represents a purely logical structure and one of which
    represents a purely physical structure, the <smLinkGrp> element
    would provide a means of mapping a <div> representing a logical
    entity (for example, a newspaper article) with multiple <div>
    elements in the physical <structMap> representing the physical
    areas that together comprise the logical entity (for example,
    the <div> elements representing the page areas that together
    comprise the newspaper article). ARCLINKORDER (enumerated
    string/O): ARCLINKORDER is used to indicate whether the order of
    the smArcLink elements aggregated by the smLinkGrp element is
    significant. If the order is significant, then a value of
    "ordered" should be supplied. Value defaults to "unordered" Note
    that the ARLINKORDER attribute has no xlink specified meaning."""

    subclass = None
    superclass = None

    def __init__(
        self,
        role=None,
        title=None,
        ARCLINKORDER='unordered',
        ID=None,
        type_=None,
        smLocatorLink=None,
        smArcLink=None,
        ):
        self.role = _cast(None, role)
        self.title = _cast(None, title)
        self.ARCLINKORDER = _cast(None, ARCLINKORDER)
        self.ID = _cast(None, ID)
        self.type_ = _cast(None, type_)
        if smLocatorLink is None:
            self.smLocatorLink = []
        else:
            self.smLocatorLink = smLocatorLink
        if smArcLink is None:
            self.smArcLink = []
        else:
            self.smArcLink = smArcLink

    def factory(*args_, **kwargs_):
        if smLinkGrp.subclass:
            return smLinkGrp.subclass(*args_, **kwargs_)
        else:
            return smLinkGrp(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_smLocatorLink(self):
        return self.smLocatorLink

    def set_smLocatorLink(self, smLocatorLink):
        self.smLocatorLink = smLocatorLink

    def add_smLocatorLink(self, value):
        self.smLocatorLink.append(value)

    def insert_smLocatorLink(self, index, value):
        self.smLocatorLink[index] = value

    def get_smArcLink(self):
        return self.smArcLink

    def set_smArcLink(self, smArcLink):
        self.smArcLink = smArcLink

    def add_smArcLink(self, value):
        self.smArcLink.append(value)

    def insert_smArcLink(self, index, value):
        self.smArcLink[index] = value

    def get_role(self):
        return self.role

    def set_role(self, role):
        self.role = role

    def get_title(self):
        return self.title

    def set_title(self, title):
        self.title = title

    def get_ARCLINKORDER(self):
        return self.ARCLINKORDER

    def set_ARCLINKORDER(self, ARCLINKORDER):
        self.ARCLINKORDER = ARCLINKORDER

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def get_type(self):
        return self.type_

    def set_type(self, type_):
        self.type_ = type_

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='smLinkGrp',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='smLinkGrp')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='smLinkGrp',
        ):
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            outfile.write(' role=%s'
                          % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding),
                          input_name='role'), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            outfile.write(' title=%s'
                          % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding),
                          input_name='title'), ))
        if self.ARCLINKORDER is not None and 'ARCLINKORDER' \
            not in already_processed:
            already_processed.append('ARCLINKORDER')
            outfile.write(' ARCLINKORDER=%s'
                          % (self.gds_format_string(quote_attrib(self.ARCLINKORDER).encode(ExternalEncoding),
                          input_name='ARCLINKORDER'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='smLinkGrp',
        ):
        for smLocatorLink_ in self.smLocatorLink:
            smLocatorLink_.export(outfile, level, namespace_,
                                  name_='smLocatorLink')
        for smArcLink_ in self.smArcLink:
            smArcLink_.export(outfile, level, namespace_,
                              name_='smArcLink')

    def hasContent_(self):
        if self.smLocatorLink or self.smArcLink:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='smLinkGrp',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            showIndent(outfile, level)
            outfile.write('role = "%s",\n' % (self.role, ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title, ))
        if self.ARCLINKORDER is not None and 'ARCLINKORDER' \
            not in already_processed:
            already_processed.append('ARCLINKORDER')
            showIndent(outfile, level)
            outfile.write('ARCLINKORDER = "%s",\n'
                          % (self.ARCLINKORDER, ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        showIndent(outfile, level)
        outfile.write('smLocatorLink=[\n')
        level += 1
        for smLocatorLink_ in self.smLocatorLink:
            showIndent(outfile, level)
            outfile.write('model_.smLocatorLink(\n')
            smLocatorLink_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('smArcLink=[\n')
        level += 1
        for smArcLink_ in self.smArcLink:
            showIndent(outfile, level)
            outfile.write('model_.smArcLink(\n')
            smArcLink_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('role')
        if value is not None and 'role' not in already_processed:
            already_processed.append('role')
            self.role = value
        value = attrs.get('title')
        if value is not None and 'title' not in already_processed:
            already_processed.append('title')
            self.title = value
        value = attrs.get('ARCLINKORDER')
        if value is not None and 'ARCLINKORDER' \
            not in already_processed:
            already_processed.append('ARCLINKORDER')
            self.ARCLINKORDER = value
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = attrs.get('type')
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        if nodeName_ == 'smLocatorLink':
            obj_ = smLocatorLink.factory()
            obj_.build(child_)
            self.smLocatorLink.append(obj_)
        elif nodeName_ == 'smArcLink':
            obj_ = smArcLink.factory()
            obj_.build(child_)
            self.smArcLink.append(obj_)


# end class smLinkGrp


class smLocatorLink(GeneratedsSuper):

    """The structMap locator link element <smLocatorLink> is of xlink:type
    "locator". It provides a means of identifying a <div> element
    that will participate in one or more of the links specified by
    means of <smArcLink> elements within the same <smLinkGrp>. The
    participating <div> element that is represented by the
    <smLocatorLink> is identified by means of a URI in the associate
    xlink:href attribute. The lowest level of this xlink:href URI
    value should be a fragment identifier that references the ID
    value that identifies the relevant <div> element. For example,
    "xlink:href='#div20'" where "div20" is the ID value that
    identifies the pertinent <div> in the current METS document.
    Although not required by the xlink specification, an
    <smLocatorLink> element will typically include an xlink:label
    attribute in this context, as the <smArcLink> elements will
    reference these labels to establish the from and to sides of
    each arc link. ID (ID/O): This attribute uniquely identifies the
    element within the METS document, and would allow the element to
    be referenced unambiguously from another element or document via
    an IDREF or an XPTR. For more information on using ID attributes
    for internal and external linking see Chapter 4 of the METS
    Primer."""

    subclass = None
    superclass = None

    def __init__(
        self,
        title=None,
        label=None,
        href=None,
        role=None,
        type_=None,
        ID=None,
        valueOf_=None,
        ):
        self.title = _cast(None, title)
        self.label = _cast(None, label)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.type_ = _cast(None, type_)
        self.ID = _cast(None, ID)
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if smLocatorLink.subclass:
            return smLocatorLink.subclass(*args_, **kwargs_)
        else:
            return smLocatorLink(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_title(self):
        return self.title

    def set_title(self, title):
        self.title = title

    def get_label(self):
        return self.label

    def set_label(self, label):
        self.label = label

    def get_href(self):
        return self.href

    def set_href(self, href):
        self.href = href

    def get_role(self):
        return self.role

    def set_role(self, role):
        self.role = role

    def get_type(self):
        return self.type_

    def set_type(self, type_):
        self.type_ = type_

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='smLocatorLink',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='smLocatorLink')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='smLocatorLink',
        ):
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            outfile.write(' title=%s'
                          % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding),
                          input_name='title'), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            outfile.write(' label=%s'
                          % (self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding),
                          input_name='label'), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            outfile.write(' href=%s'
                          % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding),
                          input_name='href'), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            outfile.write(' role=%s'
                          % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding),
                          input_name='role'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='smLocatorLink',
        ):
        pass

    def hasContent_(self):
        if self.valueOf_:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='smLocatorLink',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_, ))

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title, ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            showIndent(outfile, level)
            outfile.write('label = "%s",\n' % (self.label, ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href, ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            showIndent(outfile, level)
            outfile.write('role = "%s",\n' % (self.role, ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_, ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        pass

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('title')
        if value is not None and 'title' not in already_processed:
            already_processed.append('title')
            self.title = value
        value = attrs.get('label')
        if value is not None and 'label' not in already_processed:
            already_processed.append('label')
            self.label = value
        value = attrs.get('href')
        if value is not None and 'href' not in already_processed:
            already_processed.append('href')
            self.href = value
        value = attrs.get('role')
        if value is not None and 'role' not in already_processed:
            already_processed.append('role')
            self.role = value
        value = attrs.get('type')
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        pass


# end class smLocatorLink


class smArcLink(GeneratedsSuper):

    """The structMap arc link element <smArcLink> is of xlink:type "arc" It
    can be used to establish a traversal link between two <div>
    elements as identified by <smLocatorLink> elements within the
    same smLinkGrp element. The associated xlink:from and xlink:to
    attributes identify the from and to sides of the arc link by
    referencing the xlink:label attribute values on the
    participating smLocatorLink elements. ID (ID/O): This attribute
    uniquely identifies the element within the METS document, and
    would allow the element to be referenced unambiguously from
    another element or document via an IDREF or an XPTR. For more
    information on using ID attributes for internal and external
    linking see Chapter 4 of the METS Primer.ARCTYPE (string/O):The
    ARCTYPE attribute provides a means of specifying the
    relationship between the <div> elements participating in the arc
    link, and hence the purpose or role of the link. While it can be
    considered analogous to the xlink:arcrole attribute, its type is
    a simple string, rather than anyURI. ARCTYPE has no xlink
    specified meaning, and the xlink:arcrole attribute should be
    used instead of or in addition to the ARCTYPE attribute when
    full xlink compliance is desired with respect to specifying the
    role or purpose of the arc link. ADMID (IDREFS/O): Contains the
    ID attribute values identifying the <sourceMD>, <techMD>,
    <digiprovMD> and/or <rightsMD> elements within the <amdSec> of
    the METS document that contain or link to administrative
    metadata pertaining to <smArcLink>. Typically the <smArcLink>
    ADMID attribute would be used to identify one or more <sourceMD>
    and/or <techMD> elements that refine or clarify the relationship
    between the xlink:from and xlink:to sides of the arc. For more
    information on using METS IDREFS and IDREF type attributes for
    internal linking, see Chapter 4 of the METS Primer."""

    subclass = None
    superclass = None

    def __init__(
        self,
        ADMID=None,
        fromxx=None,
        title=None,
        show=None,
        actuate=None,
        ARCTYPE=None,
        to=None,
        arcrole=None,
        type_=None,
        ID=None,
        valueOf_=None,
        ):
        self.ADMID = _cast(None, ADMID)
        self.fromxx = _cast(None, fromxx)
        self.title = _cast(None, title)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.ARCTYPE = _cast(None, ARCTYPE)
        self.to = _cast(None, to)
        self.arcrole = _cast(None, arcrole)
        self.type_ = _cast(None, type_)
        self.ID = _cast(None, ID)
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if smArcLink.subclass:
            return smArcLink.subclass(*args_, **kwargs_)
        else:
            return smArcLink(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_ADMID(self):
        return self.ADMID

    def set_ADMID(self, ADMID):
        self.ADMID = ADMID

    def get_from(self):
        return self.fromxx

    def set_from(self, fromxx):
        self.fromxx = fromxx

    def get_title(self):
        return self.title

    def set_title(self, title):
        self.title = title

    def get_show(self):
        return self.show

    def set_show(self, show):
        self.show = show

    def get_actuate(self):
        return self.actuate

    def set_actuate(self, actuate):
        self.actuate = actuate

    def get_ARCTYPE(self):
        return self.ARCTYPE

    def set_ARCTYPE(self, ARCTYPE):
        self.ARCTYPE = ARCTYPE

    def get_to(self):
        return self.to

    def set_to(self, to):
        self.to = to

    def get_arcrole(self):
        return self.arcrole

    def set_arcrole(self, arcrole):
        self.arcrole = arcrole

    def get_type(self):
        return self.type_

    def set_type(self, type_):
        self.type_ = type_

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='smArcLink',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='smArcLink')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='smArcLink',
        ):
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            outfile.write(' ADMID=%s'
                          % (self.gds_format_string(quote_attrib(self.ADMID).encode(ExternalEncoding),
                          input_name='ADMID'), ))
        if self.fromxx is not None and 'fromxx' \
            not in already_processed:
            already_processed.append('fromxx')
            outfile.write(' from=%s'
                          % (self.gds_format_string(quote_attrib(self.fromxx).encode(ExternalEncoding),
                          input_name='from'), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            outfile.write(' title=%s'
                          % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding),
                          input_name='title'), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            outfile.write(' show=%s'
                          % (self.gds_format_string(quote_attrib(self.show).encode(ExternalEncoding),
                          input_name='show'), ))
        if self.actuate is not None and 'actuate' \
            not in already_processed:
            already_processed.append('actuate')
            outfile.write(' actuate=%s'
                          % (self.gds_format_string(quote_attrib(self.actuate).encode(ExternalEncoding),
                          input_name='actuate'), ))
        if self.ARCTYPE is not None and 'ARCTYPE' \
            not in already_processed:
            already_processed.append('ARCTYPE')
            outfile.write(' ARCTYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.ARCTYPE).encode(ExternalEncoding),
                          input_name='ARCTYPE'), ))
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            outfile.write(' to=%s'
                          % (self.gds_format_string(quote_attrib(self.to).encode(ExternalEncoding),
                          input_name='to'), ))
        if self.arcrole is not None and 'arcrole' \
            not in already_processed:
            already_processed.append('arcrole')
            outfile.write(' arcrole=%s'
                          % (self.gds_format_string(quote_attrib(self.arcrole).encode(ExternalEncoding),
                          input_name='arcrole'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='smArcLink',
        ):
        pass

    def hasContent_(self):
        if self.valueOf_:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='smArcLink',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_, ))

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            showIndent(outfile, level)
            outfile.write('ADMID = "%s",\n' % (self.ADMID, ))
        if self.fromxx is not None and 'fromxx' \
            not in already_processed:
            already_processed.append('fromxx')
            showIndent(outfile, level)
            outfile.write('fromxx = "%s",\n' % (self.fromxx, ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title, ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            showIndent(outfile, level)
            outfile.write('show = "%s",\n' % (self.show, ))
        if self.actuate is not None and 'actuate' \
            not in already_processed:
            already_processed.append('actuate')
            showIndent(outfile, level)
            outfile.write('actuate = "%s",\n' % (self.actuate, ))
        if self.ARCTYPE is not None and 'ARCTYPE' \
            not in already_processed:
            already_processed.append('ARCTYPE')
            showIndent(outfile, level)
            outfile.write('ARCTYPE = "%s",\n' % (self.ARCTYPE, ))
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            showIndent(outfile, level)
            outfile.write('to = "%s",\n' % (self.to, ))
        if self.arcrole is not None and 'arcrole' \
            not in already_processed:
            already_processed.append('arcrole')
            showIndent(outfile, level)
            outfile.write('arcrole = "%s",\n' % (self.arcrole, ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_, ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        pass

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('ADMID')
        if value is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            self.ADMID = value
        value = attrs.get('from')
        if value is not None and 'from' not in already_processed:
            already_processed.append('from')
            self.fromxx = value
        value = attrs.get('title')
        if value is not None and 'title' not in already_processed:
            already_processed.append('title')
            self.title = value
        value = attrs.get('show')
        if value is not None and 'show' not in already_processed:
            already_processed.append('show')
            self.show = value
        value = attrs.get('actuate')
        if value is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            self.actuate = value
        value = attrs.get('ARCTYPE')
        if value is not None and 'ARCTYPE' not in already_processed:
            already_processed.append('ARCTYPE')
            self.ARCTYPE = value
        value = attrs.get('to')
        if value is not None and 'to' not in already_processed:
            already_processed.append('to')
            self.to = value
        value = attrs.get('arcrole')
        if value is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            self.arcrole = value
        value = attrs.get('type')
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        pass


# end class smArcLink


class behaviorSecType(GeneratedsSuper):

    """behaviorSecType: Complex Type for Behavior Sections Behaviors are
    executable code which can be associated with parts of a METS
    object. The behaviorSec element is used to group individual
    behaviors within a hierarchical structure. Such grouping can be
    useful to organize families of behaviors together or to indicate
    other relationships between particular behaviors. ID (ID/O):
    This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    CREATED (dateTime/O): Specifies the date and time of creation
    for the <behaviorSec> LABEL (string/O): A text description of
    the behavior section."""

    subclass = None
    superclass = None

    def __init__(
        self,
        LABEL=None,
        ID=None,
        CREATED=None,
        behaviorSec=None,
        behavior=None,
        ):
        self.LABEL = _cast(None, LABEL)
        self.ID = _cast(None, ID)
        self.CREATED = _cast(None, CREATED)
        if behaviorSec is None:
            self.behaviorSec = []
        else:
            self.behaviorSec = behaviorSec
        if behavior is None:
            self.behavior = []
        else:
            self.behavior = behavior

    def factory(*args_, **kwargs_):
        if behaviorSecType.subclass:
            return behaviorSecType.subclass(*args_, **kwargs_)
        else:
            return behaviorSecType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_behaviorSec(self):
        return self.behaviorSec

    def set_behaviorSec(self, behaviorSec):
        self.behaviorSec = behaviorSec

    def add_behaviorSec(self, value):
        self.behaviorSec.append(value)

    def insert_behaviorSec(self, index, value):
        self.behaviorSec[index] = value

    def get_behavior(self):
        return self.behavior

    def set_behavior(self, behavior):
        self.behavior = behavior

    def add_behavior(self, value):
        self.behavior.append(value)

    def insert_behavior(self, index, value):
        self.behavior[index] = value

    def get_LABEL(self):
        return self.LABEL

    def set_LABEL(self, LABEL):
        self.LABEL = LABEL

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def get_CREATED(self):
        return self.CREATED

    def set_CREATED(self, CREATED):
        self.CREATED = CREATED

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='behaviorSecType',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='behaviorSecType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='behaviorSecType',
        ):
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            outfile.write(' LABEL=%s'
                          % (self.gds_format_string(quote_attrib(self.LABEL).encode(ExternalEncoding),
                          input_name='LABEL'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))
        if self.CREATED is not None and 'CREATED' \
            not in already_processed:
            already_processed.append('CREATED')
            outfile.write(' CREATED=%s'
                          % (self.gds_format_string(quote_attrib(self.CREATED).encode(ExternalEncoding),
                          input_name='CREATED'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='behaviorSecType',
        ):
        for behaviorSec_ in self.behaviorSec:
            behaviorSec_.export(outfile, level, namespace_,
                                name_='behaviorSec')
        for behavior_ in self.behavior:
            behavior_.export(outfile, level, namespace_,
                             name_='behavior')

    def hasContent_(self):
        if self.behaviorSec or self.behavior:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='behaviorSecType',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            showIndent(outfile, level)
            outfile.write('LABEL = "%s",\n' % (self.LABEL, ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))
        if self.CREATED is not None and 'CREATED' \
            not in already_processed:
            already_processed.append('CREATED')
            showIndent(outfile, level)
            outfile.write('CREATED = "%s",\n' % (self.CREATED, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        showIndent(outfile, level)
        outfile.write('behaviorSec=[\n')
        level += 1
        for behaviorSec_ in self.behaviorSec:
            showIndent(outfile, level)
            outfile.write('model_.behaviorSecType(\n')
            behaviorSec_.exportLiteral(outfile, level,
                    name_='behaviorSecType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('behavior=[\n')
        level += 1
        for behavior_ in self.behavior:
            showIndent(outfile, level)
            outfile.write('model_.behaviorType(\n')
            behavior_.exportLiteral(outfile, level, name_='behaviorType'
                                    )
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('LABEL')
        if value is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            self.LABEL = value
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = attrs.get('CREATED')
        if value is not None and 'CREATED' not in already_processed:
            already_processed.append('CREATED')
            self.CREATED = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        if nodeName_ == 'behaviorSec':
            obj_ = behaviorSecType.factory()
            obj_.build(child_)
            self.behaviorSec.append(obj_)
        elif nodeName_ == 'behavior':
            obj_ = behaviorType.factory()
            obj_.build(child_)
            self.behavior.append(obj_)


# end class behaviorSecType


class behaviorType(GeneratedsSuper):

    """behaviorType: Complex Type for Behaviors A behavior can be used to
    associate executable behaviors with content in the METS object.
    A behavior element has an interface definition element that
    represents an abstract definition of the set of behaviors
    represented by a particular behavior. A behavior element also
    has an behavior mechanism which is a module of executable code
    that implements and runs the behavior defined abstractly by the
    interface definition. ID (ID/O): This attribute uniquely
    identifies the element within the METS document, and would allow
    the element to be referenced unambiguously from another element
    or document via an IDREF or an XPTR. In the case of a <behavior>
    element that applies to a <transformFile> element, the ID value
    must be present and would be referenced from the
    transformFile/@TRANSFORMBEHAVIOR attribute. For more information
    on using ID attributes for internal and external linking see
    Chapter 4 of the METS Primer. STRUCTID (IDREFS/O): An XML IDREFS
    attribute used to link a <behavior> to one or more <div>
    elements within a <structMap> in the METS document. The content
    to which the STRUCTID points is considered input to the
    executable behavior mechanism defined for the behavior. If the
    <behavior> applies to one or more <div> elements, then the
    STRUCTID attribute must be present. BTYPE (string/O): The
    behavior type provides a means of categorizing the related
    behavior.CREATED (dateTime/O): The dateTime of creation for the
    behavior. LABEL (string/O): A text description of the behavior.
    GROUPID (string/O): An identifier that establishes a
    correspondence between the given behavior and other behaviors,
    typically used to facilitate versions of behaviors. ADMID
    (IDREFS/O): An optional attribute listing the XML ID values of
    administrative metadata sections within the METS document
    pertaining to this behavior."""

    subclass = None
    superclass = None

    def __init__(
        self,
        ADMID=None,
        CREATED=None,
        STRUCTID=None,
        LABEL=None,
        GROUPID=None,
        BTYPE=None,
        ID=None,
        interfaceDef=None,
        mechanism=None,
        ):
        self.ADMID = _cast(None, ADMID)
        self.CREATED = _cast(None, CREATED)
        self.STRUCTID = _cast(None, STRUCTID)
        self.LABEL = _cast(None, LABEL)
        self.GROUPID = _cast(None, GROUPID)
        self.BTYPE = _cast(None, BTYPE)
        self.ID = _cast(None, ID)
        self.interfaceDef = interfaceDef
        self.mechanism = mechanism

    def factory(*args_, **kwargs_):
        if behaviorType.subclass:
            return behaviorType.subclass(*args_, **kwargs_)
        else:
            return behaviorType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_interfaceDef(self):
        return self.interfaceDef

    def set_interfaceDef(self, interfaceDef):
        self.interfaceDef = interfaceDef

    def get_mechanism(self):
        return self.mechanism

    def set_mechanism(self, mechanism):
        self.mechanism = mechanism

    def get_ADMID(self):
        return self.ADMID

    def set_ADMID(self, ADMID):
        self.ADMID = ADMID

    def get_CREATED(self):
        return self.CREATED

    def set_CREATED(self, CREATED):
        self.CREATED = CREATED

    def get_STRUCTID(self):
        return self.STRUCTID

    def set_STRUCTID(self, STRUCTID):
        self.STRUCTID = STRUCTID

    def get_LABEL(self):
        return self.LABEL

    def set_LABEL(self, LABEL):
        self.LABEL = LABEL

    def get_GROUPID(self):
        return self.GROUPID

    def set_GROUPID(self, GROUPID):
        self.GROUPID = GROUPID

    def get_BTYPE(self):
        return self.BTYPE

    def set_BTYPE(self, BTYPE):
        self.BTYPE = BTYPE

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='behaviorType',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='behaviorType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='behaviorType',
        ):
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            outfile.write(' ADMID=%s'
                          % (self.gds_format_string(quote_attrib(self.ADMID).encode(ExternalEncoding),
                          input_name='ADMID'), ))
        if self.CREATED is not None and 'CREATED' \
            not in already_processed:
            already_processed.append('CREATED')
            outfile.write(' CREATED=%s'
                          % (self.gds_format_string(quote_attrib(self.CREATED).encode(ExternalEncoding),
                          input_name='CREATED'), ))
        if self.STRUCTID is not None and 'STRUCTID' \
            not in already_processed:
            already_processed.append('STRUCTID')
            outfile.write(' STRUCTID=%s'
                          % (self.gds_format_string(quote_attrib(self.STRUCTID).encode(ExternalEncoding),
                          input_name='STRUCTID'), ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            outfile.write(' LABEL=%s'
                          % (self.gds_format_string(quote_attrib(self.LABEL).encode(ExternalEncoding),
                          input_name='LABEL'), ))
        if self.GROUPID is not None and 'GROUPID' \
            not in already_processed:
            already_processed.append('GROUPID')
            outfile.write(' GROUPID=%s'
                          % (self.gds_format_string(quote_attrib(self.GROUPID).encode(ExternalEncoding),
                          input_name='GROUPID'), ))
        if self.BTYPE is not None and 'BTYPE' not in already_processed:
            already_processed.append('BTYPE')
            outfile.write(' BTYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.BTYPE).encode(ExternalEncoding),
                          input_name='BTYPE'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='behaviorType',
        ):
        if self.interfaceDef:
            self.interfaceDef.export(outfile, level, namespace_,
                    name_='interfaceDef')
        if self.mechanism:
            self.mechanism.export(outfile, level, namespace_,
                                  name_='mechanism')

    def hasContent_(self):
        if self.interfaceDef is not None or self.mechanism is not None:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='behaviorType',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            showIndent(outfile, level)
            outfile.write('ADMID = "%s",\n' % (self.ADMID, ))
        if self.CREATED is not None and 'CREATED' \
            not in already_processed:
            already_processed.append('CREATED')
            showIndent(outfile, level)
            outfile.write('CREATED = "%s",\n' % (self.CREATED, ))
        if self.STRUCTID is not None and 'STRUCTID' \
            not in already_processed:
            already_processed.append('STRUCTID')
            showIndent(outfile, level)
            outfile.write('STRUCTID = "%s",\n' % (self.STRUCTID, ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            showIndent(outfile, level)
            outfile.write('LABEL = "%s",\n' % (self.LABEL, ))
        if self.GROUPID is not None and 'GROUPID' \
            not in already_processed:
            already_processed.append('GROUPID')
            showIndent(outfile, level)
            outfile.write('GROUPID = "%s",\n' % (self.GROUPID, ))
        if self.BTYPE is not None and 'BTYPE' not in already_processed:
            already_processed.append('BTYPE')
            showIndent(outfile, level)
            outfile.write('BTYPE = "%s",\n' % (self.BTYPE, ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        if self.interfaceDef is not None:
            showIndent(outfile, level)
            outfile.write('interfaceDef=model_.objectType(\n')
            self.interfaceDef.exportLiteral(outfile, level,
                    name_='interfaceDef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mechanism is not None:
            showIndent(outfile, level)
            outfile.write('mechanism=model_.objectType(\n')
            self.mechanism.exportLiteral(outfile, level,
                    name_='mechanism')
            showIndent(outfile, level)
            outfile.write('),\n')

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('ADMID')
        if value is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            self.ADMID = value
        value = attrs.get('CREATED')
        if value is not None and 'CREATED' not in already_processed:
            already_processed.append('CREATED')
            self.CREATED = value
        value = attrs.get('STRUCTID')
        if value is not None and 'STRUCTID' not in already_processed:
            already_processed.append('STRUCTID')
            self.STRUCTID = value
        value = attrs.get('LABEL')
        if value is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            self.LABEL = value
        value = attrs.get('GROUPID')
        if value is not None and 'GROUPID' not in already_processed:
            already_processed.append('GROUPID')
            self.GROUPID = value
        value = attrs.get('BTYPE')
        if value is not None and 'BTYPE' not in already_processed:
            already_processed.append('BTYPE')
            self.BTYPE = value
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        if nodeName_ == 'interfaceDef':
            obj_ = objectType.factory()
            obj_.build(child_)
            self.set_interfaceDef(obj_)
        elif nodeName_ == 'mechanism':
            obj_ = objectType.factory()
            obj_.build(child_)
            self.set_mechanism(obj_)


# end class behaviorType


class objectType(GeneratedsSuper):

    """objectType: complexType for interfaceDef and mechanism elements The
    mechanism and behavior elements point to external objects--an
    interface definition object or an executable code object
    respectively--which together constitute a behavior that can be
    applied to one or more <div> elements in a <structMap>. ID
    (ID/O): This attribute uniquely identifies the element within
    the METS document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    LABEL (string/O): A text description of the entity represented."""

    subclass = None
    superclass = None

    def __init__(
        self,
        arcrole=None,
        title=None,
        OTHERLOCTYPE=None,
        show=None,
        actuate=None,
        LABEL=None,
        href=None,
        role=None,
        LOCTYPE=None,
        type_=None,
        ID=None,
        valueOf_=None,
        ):
        self.arcrole = _cast(None, arcrole)
        self.title = _cast(None, title)
        self.OTHERLOCTYPE = _cast(None, OTHERLOCTYPE)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.LABEL = _cast(None, LABEL)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.LOCTYPE = _cast(None, LOCTYPE)
        self.type_ = _cast(None, type_)
        self.ID = _cast(None, ID)
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if objectType.subclass:
            return objectType.subclass(*args_, **kwargs_)
        else:
            return objectType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_arcrole(self):
        return self.arcrole

    def set_arcrole(self, arcrole):
        self.arcrole = arcrole

    def get_title(self):
        return self.title

    def set_title(self, title):
        self.title = title

    def get_OTHERLOCTYPE(self):
        return self.OTHERLOCTYPE

    def set_OTHERLOCTYPE(self, OTHERLOCTYPE):
        self.OTHERLOCTYPE = OTHERLOCTYPE

    def get_show(self):
        return self.show

    def set_show(self, show):
        self.show = show

    def get_actuate(self):
        return self.actuate

    def set_actuate(self, actuate):
        self.actuate = actuate

    def get_LABEL(self):
        return self.LABEL

    def set_LABEL(self, LABEL):
        self.LABEL = LABEL

    def get_href(self):
        return self.href

    def set_href(self, href):
        self.href = href

    def get_role(self):
        return self.role

    def set_role(self, role):
        self.role = role

    def get_LOCTYPE(self):
        return self.LOCTYPE

    def set_LOCTYPE(self, LOCTYPE):
        self.LOCTYPE = LOCTYPE

    def get_type(self):
        return self.type_

    def set_type(self, type_):
        self.type_ = type_

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='objectType',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='objectType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='objectType',
        ):
        if self.arcrole is not None and 'arcrole' \
            not in already_processed:
            already_processed.append('arcrole')
            outfile.write(' arcrole=%s'
                          % (self.gds_format_string(quote_attrib(self.arcrole).encode(ExternalEncoding),
                          input_name='arcrole'), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            outfile.write(' title=%s'
                          % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding),
                          input_name='title'), ))
        if self.OTHERLOCTYPE is not None and 'OTHERLOCTYPE' \
            not in already_processed:
            already_processed.append('OTHERLOCTYPE')
            outfile.write(' OTHERLOCTYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.OTHERLOCTYPE).encode(ExternalEncoding),
                          input_name='OTHERLOCTYPE'), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            outfile.write(' show=%s'
                          % (self.gds_format_string(quote_attrib(self.show).encode(ExternalEncoding),
                          input_name='show'), ))
        if self.actuate is not None and 'actuate' \
            not in already_processed:
            already_processed.append('actuate')
            outfile.write(' actuate=%s'
                          % (self.gds_format_string(quote_attrib(self.actuate).encode(ExternalEncoding),
                          input_name='actuate'), ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            outfile.write(' LABEL=%s'
                          % (self.gds_format_string(quote_attrib(self.LABEL).encode(ExternalEncoding),
                          input_name='LABEL'), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            outfile.write(' href=%s'
                          % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding),
                          input_name='href'), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            outfile.write(' role=%s'
                          % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding),
                          input_name='role'), ))
        if self.LOCTYPE is not None and 'LOCTYPE' \
            not in already_processed:
            already_processed.append('LOCTYPE')
            outfile.write(' LOCTYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.LOCTYPE).encode(ExternalEncoding),
                          input_name='LOCTYPE'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='objectType',
        ):
        pass

    def hasContent_(self):
        if self.valueOf_:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='objectType',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_, ))

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.arcrole is not None and 'arcrole' \
            not in already_processed:
            already_processed.append('arcrole')
            showIndent(outfile, level)
            outfile.write('arcrole = "%s",\n' % (self.arcrole, ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title, ))
        if self.OTHERLOCTYPE is not None and 'OTHERLOCTYPE' \
            not in already_processed:
            already_processed.append('OTHERLOCTYPE')
            showIndent(outfile, level)
            outfile.write('OTHERLOCTYPE = "%s",\n'
                          % (self.OTHERLOCTYPE, ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            showIndent(outfile, level)
            outfile.write('show = "%s",\n' % (self.show, ))
        if self.actuate is not None and 'actuate' \
            not in already_processed:
            already_processed.append('actuate')
            showIndent(outfile, level)
            outfile.write('actuate = "%s",\n' % (self.actuate, ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            showIndent(outfile, level)
            outfile.write('LABEL = "%s",\n' % (self.LABEL, ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href, ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            showIndent(outfile, level)
            outfile.write('role = "%s",\n' % (self.role, ))
        if self.LOCTYPE is not None and 'LOCTYPE' \
            not in already_processed:
            already_processed.append('LOCTYPE')
            showIndent(outfile, level)
            outfile.write('LOCTYPE = "%s",\n' % (self.LOCTYPE, ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_, ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        pass

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('arcrole')
        if value is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            self.arcrole = value
        value = attrs.get('title')
        if value is not None and 'title' not in already_processed:
            already_processed.append('title')
            self.title = value
        value = attrs.get('OTHERLOCTYPE')
        if value is not None and 'OTHERLOCTYPE' \
            not in already_processed:
            already_processed.append('OTHERLOCTYPE')
            self.OTHERLOCTYPE = value
        value = attrs.get('show')
        if value is not None and 'show' not in already_processed:
            already_processed.append('show')
            self.show = value
        value = attrs.get('actuate')
        if value is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            self.actuate = value
        value = attrs.get('LABEL')
        if value is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            self.LABEL = value
        value = attrs.get('href')
        if value is not None and 'href' not in already_processed:
            already_processed.append('href')
            self.href = value
        value = attrs.get('role')
        if value is not None and 'role' not in already_processed:
            already_processed.append('role')
            self.role = value
        value = attrs.get('LOCTYPE')
        if value is not None and 'LOCTYPE' not in already_processed:
            already_processed.append('LOCTYPE')
            self.LOCTYPE = value
        value = attrs.get('type')
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        pass


# end class objectType


class mdSecType(GeneratedsSuper):

    """mdSecType: Complex Type for Metadata Sections A generic framework
    for pointing to/including metadata within a METS document, a la
    Warwick Framework. ID (ID/R): This attribute uniquely identifies
    the element within the METS document, and would allow the
    element to be referenced unambiguously from another element or
    document via an IDREF or an XPTR. The ID attribute on the
    <dmdSec>, <techMD>, <sourceMD>, <rightsMD> and <digiprovMD>
    elements (which are all of mdSecType) is required, and its value
    should be referenced from one or more DMDID attributes (when the
    ID identifies a <dmdSec> element) or ADMID attributes (when the
    ID identifies a <techMD>, <sourceMD>, <rightsMD> or <digiprovMD>
    element) that are associated with other elements in the METS
    document. The following elements support references to a
    <dmdSec> via a DMDID attribute: <file>, <stream>, <div>. The
    following elements support references to <techMD>, <sourceMD>,
    <rightsMD> and <digiprovMD> elements via an ADMID attribute:
    <metsHdr>, <dmdSec>, <techMD>, <sourceMD>, <rightsMD>,
    <digiprovMD>, <fileGrp>, <file>, <stream>, <div>, <area>,
    <behavior>. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    GROUPID (string/O): This identifier is used to indicate that
    different metadata sections may be considered as part of a
    group. Two metadata sections with the same GROUPID value are to
    be considered part of the same group. For example this facility
    might be used to group changed versions of the same metadata if
    previous versions are maintained in a file for tracking
    purposes. ADMID (IDREFS/O): Contains the ID attribute values of
    the <digiprovMD>, <techMD>, <sourceMD> and/or <rightsMD>
    elements within the <amdSec> of the METS document that contain
    administrative metadata pertaining to the current mdSecType
    element. Typically used in this context to reference
    preservation metadata (digiprovMD) which applies to the current
    metadata. For more information on using METS IDREFS and IDREF
    type attributes for internal linking, see Chapter 4 of the METS
    Primer. CREATED (dateTime/O): Specifies the date and time of
    creation for the metadata. STATUS (string/O): Indicates the
    status of this metadata (e.g., superseded, current, etc.)."""

    subclass = None
    superclass = None

    def __init__(
        self,
        STATUS=None,
        ADMID=None,
        CREATED=None,
        ID=None,
        GROUPID=None,
        mdRef=None,
        mdWrap=None,
        ):
        self.STATUS = _cast(None, STATUS)
        self.ADMID = _cast(None, ADMID)
        self.CREATED = _cast(None, CREATED)
        self.ID = _cast(None, ID)
        self.GROUPID = _cast(None, GROUPID)
        self.mdRef = mdRef
        self.mdWrap = mdWrap

    def factory(*args_, **kwargs_):
        if mdSecType.subclass:
            return mdSecType.subclass(*args_, **kwargs_)
        else:
            return mdSecType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_mdRef(self):
        return self.mdRef

    def set_mdRef(self, mdRef):
        self.mdRef = mdRef

    def get_mdWrap(self):
        return self.mdWrap

    def set_mdWrap(self, mdWrap):
        self.mdWrap = mdWrap

    def get_STATUS(self):
        return self.STATUS

    def set_STATUS(self, STATUS):
        self.STATUS = STATUS

    def get_ADMID(self):
        return self.ADMID

    def set_ADMID(self, ADMID):
        self.ADMID = ADMID

    def get_CREATED(self):
        return self.CREATED

    def set_CREATED(self, CREATED):
        self.CREATED = CREATED

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def get_GROUPID(self):
        return self.GROUPID

    def set_GROUPID(self, GROUPID):
        self.GROUPID = GROUPID

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='mdSecType',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='mdSecType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='mdSecType',
        ):
        if self.STATUS is not None and 'STATUS' \
            not in already_processed:
            already_processed.append('STATUS')
            outfile.write(' STATUS=%s'
                          % (self.gds_format_string(quote_attrib(self.STATUS).encode(ExternalEncoding),
                          input_name='STATUS'), ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            outfile.write(' ADMID=%s'
                          % (self.gds_format_string(quote_attrib(self.ADMID).encode(ExternalEncoding),
                          input_name='ADMID'), ))
        if self.CREATED is not None and 'CREATED' \
            not in already_processed:
            already_processed.append('CREATED')
            outfile.write(' CREATED=%s'
                          % (self.gds_format_string(quote_attrib(self.CREATED).encode(ExternalEncoding),
                          input_name='CREATED'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))
        if self.GROUPID is not None and 'GROUPID' \
            not in already_processed:
            already_processed.append('GROUPID')
            outfile.write(' GROUPID=%s'
                          % (self.gds_format_string(quote_attrib(self.GROUPID).encode(ExternalEncoding),
                          input_name='GROUPID'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='mdSecType',
        ):
        if self.mdRef:
            self.mdRef.export(outfile, level, namespace_, name_='mdRef')
        if self.mdWrap:
            self.mdWrap.export(outfile, level, namespace_,
                               name_='mdWrap')

    def hasContent_(self):
        if self.mdRef is not None or self.mdWrap is not None:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='mdSecType',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.STATUS is not None and 'STATUS' \
            not in already_processed:
            already_processed.append('STATUS')
            showIndent(outfile, level)
            outfile.write('STATUS = "%s",\n' % (self.STATUS, ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            showIndent(outfile, level)
            outfile.write('ADMID = "%s",\n' % (self.ADMID, ))
        if self.CREATED is not None and 'CREATED' \
            not in already_processed:
            already_processed.append('CREATED')
            showIndent(outfile, level)
            outfile.write('CREATED = "%s",\n' % (self.CREATED, ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))
        if self.GROUPID is not None and 'GROUPID' \
            not in already_processed:
            already_processed.append('GROUPID')
            showIndent(outfile, level)
            outfile.write('GROUPID = "%s",\n' % (self.GROUPID, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        if self.mdRef is not None:
            showIndent(outfile, level)
            outfile.write('mdRef=model_.mdRef(\n')
            self.mdRef.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mdWrap is not None:
            showIndent(outfile, level)
            outfile.write('mdWrap=model_.mdWrap(\n')
            self.mdWrap.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('STATUS')
        if value is not None and 'STATUS' not in already_processed:
            already_processed.append('STATUS')
            self.STATUS = value
        value = attrs.get('ADMID')
        if value is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            self.ADMID = value
        value = attrs.get('CREATED')
        if value is not None and 'CREATED' not in already_processed:
            already_processed.append('CREATED')
            self.CREATED = value
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = attrs.get('GROUPID')
        if value is not None and 'GROUPID' not in already_processed:
            already_processed.append('GROUPID')
            self.GROUPID = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        if nodeName_ == 'mdRef':
            obj_ = mdRef.factory()
            obj_.build(child_)
            self.set_mdRef(obj_)
        elif nodeName_ == 'mdWrap':
            obj_ = mdWrap.factory()
            obj_.build(child_)
            self.set_mdWrap(obj_)


# end class mdSecType


class mdRef(GeneratedsSuper):

    """The metadata reference element <mdRef> element is a generic element
    used throughout the METS schema to provide a pointer to metadata
    which resides outside the METS document. NB: <mdRef> is an empty
    element. The location of the metadata must be recorded in the
    xlink:href attribute, supplemented by the XPTR attribute as
    needed. ID (ID/O): This attribute uniquely identifies the
    element within the METS document, and would allow the element to
    be referenced unambiguously from another element or document via
    an IDREF or an XPTR. For more information on using ID attributes
    for internal and external linking see Chapter 4 of the METS
    Primer. LABEL (string/O): Provides a label to display to the
    viewer of the METS document that identifies the associated
    metadata. XPTR (string/O): Locates the point within a file to
    which the <mdRef> element refers, if applicable."""

    subclass = None
    superclass = None

    def __init__(
        self,
        MIMETYPE=None,
        arcrole=None,
        XPTR=None,
        CHECKSUMTYPE=None,
        show=None,
        OTHERLOCTYPE=None,
        CHECKSUM=None,
        OTHERMDTYPE=None,
        title=None,
        actuate=None,
        MDTYPE=None,
        LABEL=None,
        href=None,
        role=None,
        LOCTYPE=None,
        MDTYPEVERSION=None,
        CREATED=None,
        type_=None,
        ID=None,
        SIZE=None,
        valueOf_=None,
        ):
        self.MIMETYPE = _cast(None, MIMETYPE)
        self.arcrole = _cast(None, arcrole)
        self.XPTR = _cast(None, XPTR)
        self.CHECKSUMTYPE = _cast(None, CHECKSUMTYPE)
        self.show = _cast(None, show)
        self.OTHERLOCTYPE = _cast(None, OTHERLOCTYPE)
        self.CHECKSUM = _cast(None, CHECKSUM)
        self.OTHERMDTYPE = _cast(None, OTHERMDTYPE)
        self.title = _cast(None, title)
        self.actuate = _cast(None, actuate)
        self.MDTYPE = _cast(None, MDTYPE)
        self.LABEL = _cast(None, LABEL)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.LOCTYPE = _cast(None, LOCTYPE)
        self.MDTYPEVERSION = _cast(None, MDTYPEVERSION)
        self.CREATED = _cast(None, CREATED)
        self.type_ = _cast(None, type_)
        self.ID = _cast(None, ID)
        self.SIZE = _cast(int, SIZE)
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if mdRef.subclass:
            return mdRef.subclass(*args_, **kwargs_)
        else:
            return mdRef(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_MIMETYPE(self):
        return self.MIMETYPE

    def set_MIMETYPE(self, MIMETYPE):
        self.MIMETYPE = MIMETYPE

    def get_arcrole(self):
        return self.arcrole

    def set_arcrole(self, arcrole):
        self.arcrole = arcrole

    def get_XPTR(self):
        return self.XPTR

    def set_XPTR(self, XPTR):
        self.XPTR = XPTR

    def get_CHECKSUMTYPE(self):
        return self.CHECKSUMTYPE

    def set_CHECKSUMTYPE(self, CHECKSUMTYPE):
        self.CHECKSUMTYPE = CHECKSUMTYPE

    def get_show(self):
        return self.show

    def set_show(self, show):
        self.show = show

    def get_OTHERLOCTYPE(self):
        return self.OTHERLOCTYPE

    def set_OTHERLOCTYPE(self, OTHERLOCTYPE):
        self.OTHERLOCTYPE = OTHERLOCTYPE

    def get_CHECKSUM(self):
        return self.CHECKSUM

    def set_CHECKSUM(self, CHECKSUM):
        self.CHECKSUM = CHECKSUM

    def get_OTHERMDTYPE(self):
        return self.OTHERMDTYPE

    def set_OTHERMDTYPE(self, OTHERMDTYPE):
        self.OTHERMDTYPE = OTHERMDTYPE

    def get_title(self):
        return self.title

    def set_title(self, title):
        self.title = title

    def get_actuate(self):
        return self.actuate

    def set_actuate(self, actuate):
        self.actuate = actuate

    def get_MDTYPE(self):
        return self.MDTYPE

    def set_MDTYPE(self, MDTYPE):
        self.MDTYPE = MDTYPE

    def get_LABEL(self):
        return self.LABEL

    def set_LABEL(self, LABEL):
        self.LABEL = LABEL

    def get_href(self):
        return self.href

    def set_href(self, href):
        self.href = href

    def get_role(self):
        return self.role

    def set_role(self, role):
        self.role = role

    def get_LOCTYPE(self):
        return self.LOCTYPE

    def set_LOCTYPE(self, LOCTYPE):
        self.LOCTYPE = LOCTYPE

    def get_MDTYPEVERSION(self):
        return self.MDTYPEVERSION

    def set_MDTYPEVERSION(self, MDTYPEVERSION):
        self.MDTYPEVERSION = MDTYPEVERSION

    def get_CREATED(self):
        return self.CREATED

    def set_CREATED(self, CREATED):
        self.CREATED = CREATED

    def get_type(self):
        return self.type_

    def set_type(self, type_):
        self.type_ = type_

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def get_SIZE(self):
        return self.SIZE

    def set_SIZE(self, SIZE):
        self.SIZE = SIZE

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='mdRef',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='mdRef')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='mdRef',
        ):
        if self.MIMETYPE is not None and 'MIMETYPE' \
            not in already_processed:
            already_processed.append('MIMETYPE')
            outfile.write(' MIMETYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.MIMETYPE).encode(ExternalEncoding),
                          input_name='MIMETYPE'), ))
        if self.arcrole is not None and 'arcrole' \
            not in already_processed:
            already_processed.append('arcrole')
            outfile.write(' arcrole=%s'
                          % (self.gds_format_string(quote_attrib(self.arcrole).encode(ExternalEncoding),
                          input_name='arcrole'), ))
        if self.XPTR is not None and 'XPTR' not in already_processed:
            already_processed.append('XPTR')
            outfile.write(' XPTR=%s'
                          % (self.gds_format_string(quote_attrib(self.XPTR).encode(ExternalEncoding),
                          input_name='XPTR'), ))
        if self.CHECKSUMTYPE is not None and 'CHECKSUMTYPE' \
            not in already_processed:
            already_processed.append('CHECKSUMTYPE')
            outfile.write(' CHECKSUMTYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.CHECKSUMTYPE).encode(ExternalEncoding),
                          input_name='CHECKSUMTYPE'), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            outfile.write(' show=%s'
                          % (self.gds_format_string(quote_attrib(self.show).encode(ExternalEncoding),
                          input_name='show'), ))
        if self.OTHERLOCTYPE is not None and 'OTHERLOCTYPE' \
            not in already_processed:
            already_processed.append('OTHERLOCTYPE')
            outfile.write(' OTHERLOCTYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.OTHERLOCTYPE).encode(ExternalEncoding),
                          input_name='OTHERLOCTYPE'), ))
        if self.CHECKSUM is not None and 'CHECKSUM' \
            not in already_processed:
            already_processed.append('CHECKSUM')
            outfile.write(' CHECKSUM=%s'
                          % (self.gds_format_string(quote_attrib(self.CHECKSUM).encode(ExternalEncoding),
                          input_name='CHECKSUM'), ))
        if self.OTHERMDTYPE is not None and 'OTHERMDTYPE' \
            not in already_processed:
            already_processed.append('OTHERMDTYPE')
            outfile.write(' OTHERMDTYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.OTHERMDTYPE).encode(ExternalEncoding),
                          input_name='OTHERMDTYPE'), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            outfile.write(' title=%s'
                          % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding),
                          input_name='title'), ))
        if self.actuate is not None and 'actuate' \
            not in already_processed:
            already_processed.append('actuate')
            outfile.write(' actuate=%s'
                          % (self.gds_format_string(quote_attrib(self.actuate).encode(ExternalEncoding),
                          input_name='actuate'), ))
        if self.MDTYPE is not None and 'MDTYPE' \
            not in already_processed:
            already_processed.append('MDTYPE')
            outfile.write(' MDTYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.MDTYPE).encode(ExternalEncoding),
                          input_name='MDTYPE'), ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            outfile.write(' LABEL=%s'
                          % (self.gds_format_string(quote_attrib(self.LABEL).encode(ExternalEncoding),
                          input_name='LABEL'), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            outfile.write(' href=%s'
                          % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding),
                          input_name='href'), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            outfile.write(' role=%s'
                          % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding),
                          input_name='role'), ))
        if self.LOCTYPE is not None and 'LOCTYPE' \
            not in already_processed:
            already_processed.append('LOCTYPE')
            outfile.write(' LOCTYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.LOCTYPE).encode(ExternalEncoding),
                          input_name='LOCTYPE'), ))
        if self.MDTYPEVERSION is not None and 'MDTYPEVERSION' \
            not in already_processed:
            already_processed.append('MDTYPEVERSION')
            outfile.write(' MDTYPEVERSION=%s'
                          % (self.gds_format_string(quote_attrib(self.MDTYPEVERSION).encode(ExternalEncoding),
                          input_name='MDTYPEVERSION'), ))
        if self.CREATED is not None and 'CREATED' \
            not in already_processed:
            already_processed.append('CREATED')
            outfile.write(' CREATED=%s'
                          % (self.gds_format_string(quote_attrib(self.CREATED).encode(ExternalEncoding),
                          input_name='CREATED'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))
        if self.SIZE is not None and 'SIZE' not in already_processed:
            already_processed.append('SIZE')
            outfile.write(' SIZE="%s"'
                          % self.gds_format_integer(self.SIZE,
                          input_name='SIZE'))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='mdRef',
        ):
        pass

    def hasContent_(self):
        if self.valueOf_:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='mdRef',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_, ))

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.MIMETYPE is not None and 'MIMETYPE' \
            not in already_processed:
            already_processed.append('MIMETYPE')
            showIndent(outfile, level)
            outfile.write('MIMETYPE = "%s",\n' % (self.MIMETYPE, ))
        if self.arcrole is not None and 'arcrole' \
            not in already_processed:
            already_processed.append('arcrole')
            showIndent(outfile, level)
            outfile.write('arcrole = "%s",\n' % (self.arcrole, ))
        if self.XPTR is not None and 'XPTR' not in already_processed:
            already_processed.append('XPTR')
            showIndent(outfile, level)
            outfile.write('XPTR = "%s",\n' % (self.XPTR, ))
        if self.CHECKSUMTYPE is not None and 'CHECKSUMTYPE' \
            not in already_processed:
            already_processed.append('CHECKSUMTYPE')
            showIndent(outfile, level)
            outfile.write('CHECKSUMTYPE = "%s",\n'
                          % (self.CHECKSUMTYPE, ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            showIndent(outfile, level)
            outfile.write('show = "%s",\n' % (self.show, ))
        if self.OTHERLOCTYPE is not None and 'OTHERLOCTYPE' \
            not in already_processed:
            already_processed.append('OTHERLOCTYPE')
            showIndent(outfile, level)
            outfile.write('OTHERLOCTYPE = "%s",\n'
                          % (self.OTHERLOCTYPE, ))
        if self.CHECKSUM is not None and 'CHECKSUM' \
            not in already_processed:
            already_processed.append('CHECKSUM')
            showIndent(outfile, level)
            outfile.write('CHECKSUM = "%s",\n' % (self.CHECKSUM, ))
        if self.OTHERMDTYPE is not None and 'OTHERMDTYPE' \
            not in already_processed:
            already_processed.append('OTHERMDTYPE')
            showIndent(outfile, level)
            outfile.write('OTHERMDTYPE = "%s",\n' % (self.OTHERMDTYPE,
                          ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title, ))
        if self.actuate is not None and 'actuate' \
            not in already_processed:
            already_processed.append('actuate')
            showIndent(outfile, level)
            outfile.write('actuate = "%s",\n' % (self.actuate, ))
        if self.MDTYPE is not None and 'MDTYPE' \
            not in already_processed:
            already_processed.append('MDTYPE')
            showIndent(outfile, level)
            outfile.write('MDTYPE = "%s",\n' % (self.MDTYPE, ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            showIndent(outfile, level)
            outfile.write('LABEL = "%s",\n' % (self.LABEL, ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href, ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            showIndent(outfile, level)
            outfile.write('role = "%s",\n' % (self.role, ))
        if self.LOCTYPE is not None and 'LOCTYPE' \
            not in already_processed:
            already_processed.append('LOCTYPE')
            showIndent(outfile, level)
            outfile.write('LOCTYPE = "%s",\n' % (self.LOCTYPE, ))
        if self.MDTYPEVERSION is not None and 'MDTYPEVERSION' \
            not in already_processed:
            already_processed.append('MDTYPEVERSION')
            showIndent(outfile, level)
            outfile.write('MDTYPEVERSION = "%s",\n'
                          % (self.MDTYPEVERSION, ))
        if self.CREATED is not None and 'CREATED' \
            not in already_processed:
            already_processed.append('CREATED')
            showIndent(outfile, level)
            outfile.write('CREATED = "%s",\n' % (self.CREATED, ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_, ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))
        if self.SIZE is not None and 'SIZE' not in already_processed:
            already_processed.append('SIZE')
            showIndent(outfile, level)
            outfile.write('SIZE = %d,\n' % (self.SIZE, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        pass

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('MIMETYPE')
        if value is not None and 'MIMETYPE' not in already_processed:
            already_processed.append('MIMETYPE')
            self.MIMETYPE = value
        value = attrs.get('arcrole')
        if value is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            self.arcrole = value
        value = attrs.get('XPTR')
        if value is not None and 'XPTR' not in already_processed:
            already_processed.append('XPTR')
            self.XPTR = value
        value = attrs.get('CHECKSUMTYPE')
        if value is not None and 'CHECKSUMTYPE' \
            not in already_processed:
            already_processed.append('CHECKSUMTYPE')
            self.CHECKSUMTYPE = value
        value = attrs.get('show')
        if value is not None and 'show' not in already_processed:
            already_processed.append('show')
            self.show = value
        value = attrs.get('OTHERLOCTYPE')
        if value is not None and 'OTHERLOCTYPE' \
            not in already_processed:
            already_processed.append('OTHERLOCTYPE')
            self.OTHERLOCTYPE = value
        value = attrs.get('CHECKSUM')
        if value is not None and 'CHECKSUM' not in already_processed:
            already_processed.append('CHECKSUM')
            self.CHECKSUM = value
        value = attrs.get('OTHERMDTYPE')
        if value is not None and 'OTHERMDTYPE' not in already_processed:
            already_processed.append('OTHERMDTYPE')
            self.OTHERMDTYPE = value
        value = attrs.get('title')
        if value is not None and 'title' not in already_processed:
            already_processed.append('title')
            self.title = value
        value = attrs.get('actuate')
        if value is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            self.actuate = value
        value = attrs.get('MDTYPE')
        if value is not None and 'MDTYPE' not in already_processed:
            already_processed.append('MDTYPE')
            self.MDTYPE = value
        value = attrs.get('LABEL')
        if value is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            self.LABEL = value
        value = attrs.get('href')
        if value is not None and 'href' not in already_processed:
            already_processed.append('href')
            self.href = value
        value = attrs.get('role')
        if value is not None and 'role' not in already_processed:
            already_processed.append('role')
            self.role = value
        value = attrs.get('LOCTYPE')
        if value is not None and 'LOCTYPE' not in already_processed:
            already_processed.append('LOCTYPE')
            self.LOCTYPE = value
        value = attrs.get('MDTYPEVERSION')
        if value is not None and 'MDTYPEVERSION' \
            not in already_processed:
            already_processed.append('MDTYPEVERSION')
            self.MDTYPEVERSION = value
        value = attrs.get('CREATED')
        if value is not None and 'CREATED' not in already_processed:
            already_processed.append('CREATED')
            self.CREATED = value
        value = attrs.get('type')
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = attrs.get('SIZE')
        if value is not None and 'SIZE' not in already_processed:
            already_processed.append('SIZE')
            try:
                self.SIZE = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s'
                                  % exp)

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        pass


# end class mdRef


class mdWrap(GeneratedsSuper):

    """A metadata wrapper element <mdWrap> provides a wrapper around
    metadata embedded within a METS document. The element is
    repeatable. Such metadata can be in one of two forms: 1) XML-
    encoded metadata, with the XML-encoding identifying itself as
    belonging to a namespace other than the METS document namespace.
    2) Any arbitrary binary or textual form, PROVIDED that the
    metadata is Base64 encoded and wrapped in a <binData> element
    within the internal descriptive metadata element. ID (ID/O):
    This attribute uniquely identifies the element within the METS
    document, and would allow the element to be referenced
    unambiguously from another element or document via an IDREF or
    an XPTR. For more information on using ID attributes for
    internal and external linking see Chapter 4 of the METS Primer.
    LABEL: an optional string attribute providing a label to display
    to the viewer of the METS document identifying the metadata."""

    subclass = None
    superclass = None

    def __init__(
        self,
        MIMETYPE=None,
        CHECKSUMTYPE=None,
        CREATED=None,
        CHECKSUM=None,
        OTHERMDTYPE=None,
        MDTYPE=None,
        LABEL=None,
        MDTYPEVERSION=None,
        ID=None,
        SIZE=None,
        binData=None,
        xmlData=None,
        ):
        self.MIMETYPE = _cast(None, MIMETYPE)
        self.CHECKSUMTYPE = _cast(None, CHECKSUMTYPE)
        self.CREATED = _cast(None, CREATED)
        self.CHECKSUM = _cast(None, CHECKSUM)
        self.OTHERMDTYPE = _cast(None, OTHERMDTYPE)
        self.MDTYPE = _cast(None, MDTYPE)
        self.LABEL = _cast(None, LABEL)
        self.MDTYPEVERSION = _cast(None, MDTYPEVERSION)
        self.ID = _cast(None, ID)
        self.SIZE = _cast(int, SIZE)
        self.binData = binData
        self.xmlData = xmlData

    def factory(*args_, **kwargs_):
        if mdWrap.subclass:
            return mdWrap.subclass(*args_, **kwargs_)
        else:
            return mdWrap(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_binData(self):
        return self.binData

    def set_binData(self, binData):
        self.binData = binData

    def get_xmlData(self):
        return self.xmlData

    def set_xmlData(self, xmlData):
        self.xmlData = xmlData

    def get_MIMETYPE(self):
        return self.MIMETYPE

    def set_MIMETYPE(self, MIMETYPE):
        self.MIMETYPE = MIMETYPE

    def get_CHECKSUMTYPE(self):
        return self.CHECKSUMTYPE

    def set_CHECKSUMTYPE(self, CHECKSUMTYPE):
        self.CHECKSUMTYPE = CHECKSUMTYPE

    def get_CREATED(self):
        return self.CREATED

    def set_CREATED(self, CREATED):
        self.CREATED = CREATED

    def get_CHECKSUM(self):
        return self.CHECKSUM

    def set_CHECKSUM(self, CHECKSUM):
        self.CHECKSUM = CHECKSUM

    def get_OTHERMDTYPE(self):
        return self.OTHERMDTYPE

    def set_OTHERMDTYPE(self, OTHERMDTYPE):
        self.OTHERMDTYPE = OTHERMDTYPE

    def get_MDTYPE(self):
        return self.MDTYPE

    def set_MDTYPE(self, MDTYPE):
        self.MDTYPE = MDTYPE

    def get_LABEL(self):
        return self.LABEL

    def set_LABEL(self, LABEL):
        self.LABEL = LABEL

    def get_MDTYPEVERSION(self):
        return self.MDTYPEVERSION

    def set_MDTYPEVERSION(self, MDTYPEVERSION):
        self.MDTYPEVERSION = MDTYPEVERSION

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def get_SIZE(self):
        return self.SIZE

    def set_SIZE(self, SIZE):
        self.SIZE = SIZE

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='mdWrap',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='mdWrap')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='mdWrap',
        ):
        if self.MIMETYPE is not None and 'MIMETYPE' \
            not in already_processed:
            already_processed.append('MIMETYPE')
            outfile.write(' MIMETYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.MIMETYPE).encode(ExternalEncoding),
                          input_name='MIMETYPE'), ))
        if self.CHECKSUMTYPE is not None and 'CHECKSUMTYPE' \
            not in already_processed:
            already_processed.append('CHECKSUMTYPE')
            outfile.write(' CHECKSUMTYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.CHECKSUMTYPE).encode(ExternalEncoding),
                          input_name='CHECKSUMTYPE'), ))
        if self.CREATED is not None and 'CREATED' \
            not in already_processed:
            already_processed.append('CREATED')
            outfile.write(' CREATED=%s'
                          % (self.gds_format_string(quote_attrib(self.CREATED).encode(ExternalEncoding),
                          input_name='CREATED'), ))
        if self.CHECKSUM is not None and 'CHECKSUM' \
            not in already_processed:
            already_processed.append('CHECKSUM')
            outfile.write(' CHECKSUM=%s'
                          % (self.gds_format_string(quote_attrib(self.CHECKSUM).encode(ExternalEncoding),
                          input_name='CHECKSUM'), ))
        if self.OTHERMDTYPE is not None and 'OTHERMDTYPE' \
            not in already_processed:
            already_processed.append('OTHERMDTYPE')
            outfile.write(' OTHERMDTYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.OTHERMDTYPE).encode(ExternalEncoding),
                          input_name='OTHERMDTYPE'), ))
        if self.MDTYPE is not None and 'MDTYPE' \
            not in already_processed:
            already_processed.append('MDTYPE')
            outfile.write(' MDTYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.MDTYPE).encode(ExternalEncoding),
                          input_name='MDTYPE'), ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            outfile.write(' LABEL=%s'
                          % (self.gds_format_string(quote_attrib(self.LABEL).encode(ExternalEncoding),
                          input_name='LABEL'), ))
        if self.MDTYPEVERSION is not None and 'MDTYPEVERSION' \
            not in already_processed:
            already_processed.append('MDTYPEVERSION')
            outfile.write(' MDTYPEVERSION=%s'
                          % (self.gds_format_string(quote_attrib(self.MDTYPEVERSION).encode(ExternalEncoding),
                          input_name='MDTYPEVERSION'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))
        if self.SIZE is not None and 'SIZE' not in already_processed:
            already_processed.append('SIZE')
            outfile.write(' SIZE="%s"'
                          % self.gds_format_integer(self.SIZE,
                          input_name='SIZE'))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='mdWrap',
        ):
        if self.binData is not None:
            showIndent(outfile, level)
            outfile.write('<%sbinData>%s</%sbinData>\n' % (namespace_,
                          self.gds_format_string(quote_xml(self.binData).encode(ExternalEncoding),
                          input_name='binData'), namespace_))
        if self.xmlData is not None:

            # showIndent(outfile, level)

            self.xmlData.export(outfile, level, namespace_)  # name_, namespacedef_)

            # outfile.write('<%sxmlData>%s</%sxmlData>\n' % (namespace_, self.gds_format_string(quote_xml(self.xmlData).encode(ExternalEncoding), input_name='xmlData'), namespace_))

    def hasContent_(self):
        if self.binData is not None or self.xmlData is not None:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='mdWrap',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.MIMETYPE is not None and 'MIMETYPE' \
            not in already_processed:
            already_processed.append('MIMETYPE')
            showIndent(outfile, level)
            outfile.write('MIMETYPE = "%s",\n' % (self.MIMETYPE, ))
        if self.CHECKSUMTYPE is not None and 'CHECKSUMTYPE' \
            not in already_processed:
            already_processed.append('CHECKSUMTYPE')
            showIndent(outfile, level)
            outfile.write('CHECKSUMTYPE = "%s",\n'
                          % (self.CHECKSUMTYPE, ))
        if self.CREATED is not None and 'CREATED' \
            not in already_processed:
            already_processed.append('CREATED')
            showIndent(outfile, level)
            outfile.write('CREATED = "%s",\n' % (self.CREATED, ))
        if self.CHECKSUM is not None and 'CHECKSUM' \
            not in already_processed:
            already_processed.append('CHECKSUM')
            showIndent(outfile, level)
            outfile.write('CHECKSUM = "%s",\n' % (self.CHECKSUM, ))
        if self.OTHERMDTYPE is not None and 'OTHERMDTYPE' \
            not in already_processed:
            already_processed.append('OTHERMDTYPE')
            showIndent(outfile, level)
            outfile.write('OTHERMDTYPE = "%s",\n' % (self.OTHERMDTYPE,
                          ))
        if self.MDTYPE is not None and 'MDTYPE' \
            not in already_processed:
            already_processed.append('MDTYPE')
            showIndent(outfile, level)
            outfile.write('MDTYPE = "%s",\n' % (self.MDTYPE, ))
        if self.LABEL is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            showIndent(outfile, level)
            outfile.write('LABEL = "%s",\n' % (self.LABEL, ))
        if self.MDTYPEVERSION is not None and 'MDTYPEVERSION' \
            not in already_processed:
            already_processed.append('MDTYPEVERSION')
            showIndent(outfile, level)
            outfile.write('MDTYPEVERSION = "%s",\n'
                          % (self.MDTYPEVERSION, ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))
        if self.SIZE is not None and 'SIZE' not in already_processed:
            already_processed.append('SIZE')
            showIndent(outfile, level)
            outfile.write('SIZE = %d,\n' % (self.SIZE, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        if self.binData is not None:
            showIndent(outfile, level)
            outfile.write('binData=%s,\n'
                          % quote_python(self.binData).encode(ExternalEncoding))
        if self.xmlData is not None:
            showIndent(outfile, level)
            outfile.write('xmlData=%s,\n'
                          % quote_python(self.xmlData).encode(ExternalEncoding))

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('MIMETYPE')
        if value is not None and 'MIMETYPE' not in already_processed:
            already_processed.append('MIMETYPE')
            self.MIMETYPE = value
        value = attrs.get('CHECKSUMTYPE')
        if value is not None and 'CHECKSUMTYPE' \
            not in already_processed:
            already_processed.append('CHECKSUMTYPE')
            self.CHECKSUMTYPE = value
        value = attrs.get('CREATED')
        if value is not None and 'CREATED' not in already_processed:
            already_processed.append('CREATED')
            self.CREATED = value
        value = attrs.get('CHECKSUM')
        if value is not None and 'CHECKSUM' not in already_processed:
            already_processed.append('CHECKSUM')
            self.CHECKSUM = value
        value = attrs.get('OTHERMDTYPE')
        if value is not None and 'OTHERMDTYPE' not in already_processed:
            already_processed.append('OTHERMDTYPE')
            self.OTHERMDTYPE = value
        value = attrs.get('MDTYPE')
        if value is not None and 'MDTYPE' not in already_processed:
            already_processed.append('MDTYPE')
            self.MDTYPE = value
        value = attrs.get('LABEL')
        if value is not None and 'LABEL' not in already_processed:
            already_processed.append('LABEL')
            self.LABEL = value
        value = attrs.get('MDTYPEVERSION')
        if value is not None and 'MDTYPEVERSION' \
            not in already_processed:
            already_processed.append('MDTYPEVERSION')
            self.MDTYPEVERSION = value
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = attrs.get('SIZE')
        if value is not None and 'SIZE' not in already_processed:
            already_processed.append('SIZE')
            try:
                self.SIZE = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s'
                                  % exp)

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        if nodeName_ == 'binData':
            binData_ = child_.text
            binData_ = self.gds_validate_string(binData_, node,
                    'binData')
            self.binData = binData_
        elif nodeName_ == 'xmlData':
            xmlData_ = child_.text
            xmlData_ = self.gds_validate_string(xmlData_, node,
                    'xmlData')
            self.xmlData = xmlData_


# end class mdWrap


class xmlData(GeneratedsSuper):

    """The xml data wrapper element <xmlData> is used to contain XML
    encoded metadata. The content of an <xmlData> element can be in
    any namespace or in no namespace. As permitted by the XML Schema
    Standard, the processContents attribute value for the metadata
    in an <xmlData> is set to "lax". Therefore, if the source
    schema and its location are identified by means of an XML
    schemaLocation attribute, then an XML processor will validate
    the elements for which it can find declarations. If a source
    schema is not identified, or cannot be found at the specified
    schemaLocation, then an XML validator will check for well-
    formedness, but otherwise skip over the elements appearing in
    the <xmlData> element."""

    subclass = None
    superclass = None

    def __init__(self, xsdAny_=None):
        if xsdAny_ is None:
            self.xsdAny_ = []
        else:
            self.xsdAny_ = xsdAny_

    def factory(*args_, **kwargs_):
        if xmlData.subclass:
            return xmlData.subclass(*args_, **kwargs_)
        else:
            return xmlData(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_xsdAny_(self):
        return self.xsdAny_

    def set_xsdAny_(self, xsdAny_):
        self.xsdAny_ = xsdAny_

    def add_xsdAny_(self, value):
        self.xsdAny_.append(value)

    def insert_xsdAny_(self, index, value):
        self.xsdAny_[index] = value

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='xmlData',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='xmlData')
        if self.hasContent_():
            outfile.write('>')
            from elementtree.ElementTree import tostring
            for xsdAnyContent in self.xsdAny_:
                outfile.write(tostring(xsdAnyContent))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='xmlData',
        ):
        pass

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='xmlData',
        ):
        pass

    def hasContent_(self):
        if self.xsdAny_:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='xmlData',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_, ))

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        pass

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        pass

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        pass

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        pass


# end class xmlData


class fileType(GeneratedsSuper):

    """fileType: Complex Type for Files The file element provides access to
    content files for a METS object. A file element may contain one
    or more FLocat elements, which provide pointers to a content
    file, and/or an FContent element, which wraps an encoded version
    of the file. Note that ALL FLocat and FContent elements
    underneath a single file element should identify/contain
    identical copies of a single file. ID (ID/R): This attribute
    uniquely identifies the element within the METS document, and
    would allow the element to be referenced unambiguously from
    another element or document via an IDREF or an XPTR. Typically,
    the ID attribute value on a <file> element would be referenced
    from one or more FILEID attributes (which are of type IDREF) on
    <fptr>and/or <area> elements within the <structMap>. Such
    references establish links between structural divisions (<div>
    elements) and the specific content files or parts of content
    files that manifest them. For more information on using ID
    attributes for internal and external linking see Chapter 4 of
    the METS Primer. SEQ (integer/O): Indicates the sequence of this
    <file> relative to the others in its <fileGrp>. OWNERID
    (string/O): A unique identifier assigned to the file by its
    owner. This may be a URI which differs from the URI used to
    retrieve the file. ADMID (IDREFS/O): Contains the ID attribute
    values of the <techMD>, <sourceMD>, <rightsMD> and/or
    <digiprovMD> elements within the <amdSec> of the METS document
    that contain administrative metadata pertaining to the file. For
    more information on using METS IDREFS and IDREF type attributes
    for internal linking, see Chapter 4 of the METS Primer. DMDID
    (IDREFS/O): Contains the ID attribute values identifying the
    <dmdSec>, elements in the METS document that contain or link to
    descriptive metadata pertaining to the content file represented
    by the current <file> element. For more information on using
    METS IDREFS and IDREF type attributes for internal linking, see
    Chapter 4 of the METS Primer. GROUPID (string/O): An identifier
    that establishes a correspondence between this file and files in
    other file groups. Typically, this will be used to associate a
    master file in one file group with the derivative files made
    from it in other file groups. USE (string/O): A tagging
    attribute to indicate the intended use of all copies of the file
    aggregated by the <file> element (e.g., master, reference,
    thumbnails for image files). A USE attribute can be expressed at
    the<fileGrp> level, the <file> level, the <FLocat> level and/or
    the <FContent> level. A USE attribute value at the <fileGrp>
    level should pertain to all of the files in the <fileGrp>. A USE
    attribute at the <file> level should pertain to all copies of
    the file as represented by subsidiary <FLocat> and/or <FContent>
    elements. A USE attribute at the <FLocat> or <FContent> level
    pertains to the particular copy of the file that is either
    referenced (<FLocat>) or wrapped (<FContent>). BEGIN (string/O):
    An attribute that specifies the point in the parent <file> where
    the current <file> begins. When used in conjunction with a
    <file> element, this attribute is only meaningful when this
    element is nested, and its parent <file> element represents a
    container file. It can be used in conjunction with the END
    attribute as a means of defining the location of the current
    file within its parent file. However, the BEGIN attribute can be
    used with or without a companion END attribute. When no END
    attribute is specified, the end of the parent file is assumed
    also to be the end point of the current file. The BEGIN and END
    attributes can only be interpreted meaningfully in conjunction
    with a BETYPE attribute, which specifies the kind of
    beginning/ending point values that are being used. END
    (string/O): An attribute that specifies the point in the parent
    <file> where the current, nested <file> ends. It can only be
    interpreted meaningfully in conjunction with the BETYPE, which
    specifies the kind of ending point values being used. Typically
    the END attribute would only appear in conjunction with a BEGIN
    attribute. BETYPE: Begin/End Type. BETYPE (string/O): An
    attribute that specifies the kind of BEGIN and/or END values
    that are being used. Currently BYTE is the only valid value that
    can be used in conjunction with nested <file> or <stream>
    elements."""

    subclass = None
    superclass = None

    def __init__(
        self,
        MIMETYPE=None,
        ADMID=None,
        END=None,
        CHECKSUMTYPE=None,
        SEQ=None,
        CREATED=None,
        CHECKSUM=None,
        USE=None,
        ID=None,
        DMDID=None,
        BEGIN=None,
        OWNERID=None,
        SIZE=None,
        GROUPID=None,
        BETYPE=None,
        FLocat=None,
        FContent=None,
        stream=None,
        transformFile=None,
        file=None,
        ):
        self.MIMETYPE = _cast(None, MIMETYPE)
        self.ADMID = _cast(None, ADMID)
        self.END = _cast(None, END)
        self.CHECKSUMTYPE = _cast(None, CHECKSUMTYPE)
        self.SEQ = _cast(int, SEQ)
        self.CREATED = _cast(None, CREATED)
        self.CHECKSUM = _cast(None, CHECKSUM)
        self.USE = _cast(None, USE)
        self.ID = _cast(None, ID)
        self.DMDID = _cast(None, DMDID)
        self.BEGIN = _cast(None, BEGIN)
        self.OWNERID = _cast(None, OWNERID)
        self.SIZE = _cast(int, SIZE)
        self.GROUPID = _cast(None, GROUPID)
        self.BETYPE = _cast(None, BETYPE)
        if FLocat is None:
            self.FLocat = []
        else:
            self.FLocat = FLocat
        self.FContent = FContent
        if stream is None:
            self.stream = []
        else:
            self.stream = stream
        if transformFile is None:
            self.transformFile = []
        else:
            self.transformFile = transformFile
        if file is None:
            self.file = []
        else:
            self.file = file

    def factory(*args_, **kwargs_):
        if fileType.subclass:
            return fileType.subclass(*args_, **kwargs_)
        else:
            return fileType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_FLocat(self):
        return self.FLocat

    def set_FLocat(self, FLocat):
        self.FLocat = FLocat

    def add_FLocat(self, value):
        self.FLocat.append(value)

    def insert_FLocat(self, index, value):
        self.FLocat[index] = value

    def get_FContent(self):
        return self.FContent

    def set_FContent(self, FContent):
        self.FContent = FContent

    def get_stream(self):
        return self.stream

    def set_stream(self, stream):
        self.stream = stream

    def add_stream(self, value):
        self.stream.append(value)

    def insert_stream(self, index, value):
        self.stream[index] = value

    def get_transformFile(self):
        return self.transformFile

    def set_transformFile(self, transformFile):
        self.transformFile = transformFile

    def add_transformFile(self, value):
        self.transformFile.append(value)

    def insert_transformFile(self, index, value):
        self.transformFile[index] = value

    def get_file(self):
        return self.file

    def set_file(self, file):
        self.file = file

    def add_file(self, value):
        self.file.append(value)

    def insert_file(self, index, value):
        self.file[index] = value

    def get_MIMETYPE(self):
        return self.MIMETYPE

    def set_MIMETYPE(self, MIMETYPE):
        self.MIMETYPE = MIMETYPE

    def get_ADMID(self):
        return self.ADMID

    def set_ADMID(self, ADMID):
        self.ADMID = ADMID

    def get_END(self):
        return self.END

    def set_END(self, END):
        self.END = END

    def get_CHECKSUMTYPE(self):
        return self.CHECKSUMTYPE

    def set_CHECKSUMTYPE(self, CHECKSUMTYPE):
        self.CHECKSUMTYPE = CHECKSUMTYPE

    def get_SEQ(self):
        return self.SEQ

    def set_SEQ(self, SEQ):
        self.SEQ = SEQ

    def get_CREATED(self):
        return self.CREATED

    def set_CREATED(self, CREATED):
        self.CREATED = CREATED

    def get_CHECKSUM(self):
        return self.CHECKSUM

    def set_CHECKSUM(self, CHECKSUM):
        self.CHECKSUM = CHECKSUM

    def get_USE(self):
        return self.USE

    def set_USE(self, USE):
        self.USE = USE

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def get_DMDID(self):
        return self.DMDID

    def set_DMDID(self, DMDID):
        self.DMDID = DMDID

    def get_BEGIN(self):
        return self.BEGIN

    def set_BEGIN(self, BEGIN):
        self.BEGIN = BEGIN

    def get_OWNERID(self):
        return self.OWNERID

    def set_OWNERID(self, OWNERID):
        self.OWNERID = OWNERID

    def get_SIZE(self):
        return self.SIZE

    def set_SIZE(self, SIZE):
        self.SIZE = SIZE

    def get_GROUPID(self):
        return self.GROUPID

    def set_GROUPID(self, GROUPID):
        self.GROUPID = GROUPID

    def get_BETYPE(self):
        return self.BETYPE

    def set_BETYPE(self, BETYPE):
        self.BETYPE = BETYPE

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='fileType',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='fileType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='fileType',
        ):
        if self.MIMETYPE is not None and 'MIMETYPE' \
            not in already_processed:
            already_processed.append('MIMETYPE')
            outfile.write(' MIMETYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.MIMETYPE).encode(ExternalEncoding),
                          input_name='MIMETYPE'), ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            outfile.write(' ADMID=%s'
                          % (self.gds_format_string(quote_attrib(self.ADMID).encode(ExternalEncoding),
                          input_name='ADMID'), ))
        if self.END is not None and 'END' not in already_processed:
            already_processed.append('END')
            outfile.write(' END=%s'
                          % (self.gds_format_string(quote_attrib(self.END).encode(ExternalEncoding),
                          input_name='END'), ))
        if self.CHECKSUMTYPE is not None and 'CHECKSUMTYPE' \
            not in already_processed:
            already_processed.append('CHECKSUMTYPE')
            outfile.write(' CHECKSUMTYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.CHECKSUMTYPE).encode(ExternalEncoding),
                          input_name='CHECKSUMTYPE'), ))
        if self.SEQ is not None and 'SEQ' not in already_processed:
            already_processed.append('SEQ')
            outfile.write(' SEQ="%s"'
                          % self.gds_format_integer(self.SEQ,
                          input_name='SEQ'))
        if self.CREATED is not None and 'CREATED' \
            not in already_processed:
            already_processed.append('CREATED')
            outfile.write(' CREATED=%s'
                          % (self.gds_format_string(quote_attrib(self.CREATED).encode(ExternalEncoding),
                          input_name='CREATED'), ))
        if self.CHECKSUM is not None and 'CHECKSUM' \
            not in already_processed:
            already_processed.append('CHECKSUM')
            outfile.write(' CHECKSUM=%s'
                          % (self.gds_format_string(quote_attrib(self.CHECKSUM).encode(ExternalEncoding),
                          input_name='CHECKSUM'), ))
        if self.USE is not None and 'USE' not in already_processed:
            already_processed.append('USE')
            outfile.write(' USE=%s'
                          % (self.gds_format_string(quote_attrib(self.USE).encode(ExternalEncoding),
                          input_name='USE'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))
        if self.DMDID is not None and 'DMDID' not in already_processed:
            already_processed.append('DMDID')
            outfile.write(' DMDID=%s'
                          % (self.gds_format_string(quote_attrib(self.DMDID).encode(ExternalEncoding),
                          input_name='DMDID'), ))
        if self.BEGIN is not None and 'BEGIN' not in already_processed:
            already_processed.append('BEGIN')
            outfile.write(' BEGIN=%s'
                          % (self.gds_format_string(quote_attrib(self.BEGIN).encode(ExternalEncoding),
                          input_name='BEGIN'), ))
        if self.OWNERID is not None and 'OWNERID' \
            not in already_processed:
            already_processed.append('OWNERID')
            outfile.write(' OWNERID=%s'
                          % (self.gds_format_string(quote_attrib(self.OWNERID).encode(ExternalEncoding),
                          input_name='OWNERID'), ))
        if self.SIZE is not None and 'SIZE' not in already_processed:
            already_processed.append('SIZE')
            outfile.write(' SIZE="%s"'
                          % self.gds_format_integer(self.SIZE,
                          input_name='SIZE'))
        if self.GROUPID is not None and 'GROUPID' \
            not in already_processed:
            already_processed.append('GROUPID')
            outfile.write(' GROUPID=%s'
                          % (self.gds_format_string(quote_attrib(self.GROUPID).encode(ExternalEncoding),
                          input_name='GROUPID'), ))
        if self.BETYPE is not None and 'BETYPE' \
            not in already_processed:
            already_processed.append('BETYPE')
            outfile.write(' BETYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.BETYPE).encode(ExternalEncoding),
                          input_name='BETYPE'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='fileType',
        ):
        for FLocat_ in self.FLocat:
            FLocat_.export(outfile, level, namespace_, name_='FLocat')
        if self.FContent:
            self.FContent.export(outfile, level, namespace_,
                                 name_='FContent')
        for stream_ in self.stream:
            stream_.export(outfile, level, namespace_, name_='stream')
        for transformFile_ in self.transformFile:
            transformFile_.export(outfile, level, namespace_,
                                  name_='transformFile')
        for file_ in self.file:
            file_.export(outfile, level, namespace_, name_='file')

    def hasContent_(self):
        if self.FLocat or self.FContent is not None or self.stream \
            or self.transformFile or self.file:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='fileType',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.MIMETYPE is not None and 'MIMETYPE' \
            not in already_processed:
            already_processed.append('MIMETYPE')
            showIndent(outfile, level)
            outfile.write('MIMETYPE = "%s",\n' % (self.MIMETYPE, ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            showIndent(outfile, level)
            outfile.write('ADMID = "%s",\n' % (self.ADMID, ))
        if self.END is not None and 'END' not in already_processed:
            already_processed.append('END')
            showIndent(outfile, level)
            outfile.write('END = "%s",\n' % (self.END, ))
        if self.CHECKSUMTYPE is not None and 'CHECKSUMTYPE' \
            not in already_processed:
            already_processed.append('CHECKSUMTYPE')
            showIndent(outfile, level)
            outfile.write('CHECKSUMTYPE = "%s",\n'
                          % (self.CHECKSUMTYPE, ))
        if self.SEQ is not None and 'SEQ' not in already_processed:
            already_processed.append('SEQ')
            showIndent(outfile, level)
            outfile.write('SEQ = %d,\n' % (self.SEQ, ))
        if self.CREATED is not None and 'CREATED' \
            not in already_processed:
            already_processed.append('CREATED')
            showIndent(outfile, level)
            outfile.write('CREATED = "%s",\n' % (self.CREATED, ))
        if self.CHECKSUM is not None and 'CHECKSUM' \
            not in already_processed:
            already_processed.append('CHECKSUM')
            showIndent(outfile, level)
            outfile.write('CHECKSUM = "%s",\n' % (self.CHECKSUM, ))
        if self.USE is not None and 'USE' not in already_processed:
            already_processed.append('USE')
            showIndent(outfile, level)
            outfile.write('USE = "%s",\n' % (self.USE, ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))
        if self.DMDID is not None and 'DMDID' not in already_processed:
            already_processed.append('DMDID')
            showIndent(outfile, level)
            outfile.write('DMDID = "%s",\n' % (self.DMDID, ))
        if self.BEGIN is not None and 'BEGIN' not in already_processed:
            already_processed.append('BEGIN')
            showIndent(outfile, level)
            outfile.write('BEGIN = "%s",\n' % (self.BEGIN, ))
        if self.OWNERID is not None and 'OWNERID' \
            not in already_processed:
            already_processed.append('OWNERID')
            showIndent(outfile, level)
            outfile.write('OWNERID = "%s",\n' % (self.OWNERID, ))
        if self.SIZE is not None and 'SIZE' not in already_processed:
            already_processed.append('SIZE')
            showIndent(outfile, level)
            outfile.write('SIZE = %d,\n' % (self.SIZE, ))
        if self.GROUPID is not None and 'GROUPID' \
            not in already_processed:
            already_processed.append('GROUPID')
            showIndent(outfile, level)
            outfile.write('GROUPID = "%s",\n' % (self.GROUPID, ))
        if self.BETYPE is not None and 'BETYPE' \
            not in already_processed:
            already_processed.append('BETYPE')
            showIndent(outfile, level)
            outfile.write('BETYPE = "%s",\n' % (self.BETYPE, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        showIndent(outfile, level)
        outfile.write('FLocat=[\n')
        level += 1
        for FLocat_ in self.FLocat:
            showIndent(outfile, level)
            outfile.write('model_.FLocat(\n')
            FLocat_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.FContent is not None:
            showIndent(outfile, level)
            outfile.write('FContent=model_.FContent(\n')
            self.FContent.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('stream=[\n')
        level += 1
        for stream_ in self.stream:
            showIndent(outfile, level)
            outfile.write('model_.stream(\n')
            stream_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('transformFile=[\n')
        level += 1
        for transformFile_ in self.transformFile:
            showIndent(outfile, level)
            outfile.write('model_.transformFile(\n')
            transformFile_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('file=[\n')
        level += 1
        for file_ in self.file:
            showIndent(outfile, level)
            outfile.write('model_.fileType(\n')
            file_.exportLiteral(outfile, level, name_='fileType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('MIMETYPE')
        if value is not None and 'MIMETYPE' not in already_processed:
            already_processed.append('MIMETYPE')
            self.MIMETYPE = value
        value = attrs.get('ADMID')
        if value is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            self.ADMID = value
        value = attrs.get('END')
        if value is not None and 'END' not in already_processed:
            already_processed.append('END')
            self.END = value
        value = attrs.get('CHECKSUMTYPE')
        if value is not None and 'CHECKSUMTYPE' \
            not in already_processed:
            already_processed.append('CHECKSUMTYPE')
            self.CHECKSUMTYPE = value
        value = attrs.get('SEQ')
        if value is not None and 'SEQ' not in already_processed:
            already_processed.append('SEQ')
            try:
                self.SEQ = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s'
                                  % exp)
        value = attrs.get('CREATED')
        if value is not None and 'CREATED' not in already_processed:
            already_processed.append('CREATED')
            self.CREATED = value
        value = attrs.get('CHECKSUM')
        if value is not None and 'CHECKSUM' not in already_processed:
            already_processed.append('CHECKSUM')
            self.CHECKSUM = value
        value = attrs.get('USE')
        if value is not None and 'USE' not in already_processed:
            already_processed.append('USE')
            self.USE = value
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = attrs.get('DMDID')
        if value is not None and 'DMDID' not in already_processed:
            already_processed.append('DMDID')
            self.DMDID = value
        value = attrs.get('BEGIN')
        if value is not None and 'BEGIN' not in already_processed:
            already_processed.append('BEGIN')
            self.BEGIN = value
        value = attrs.get('OWNERID')
        if value is not None and 'OWNERID' not in already_processed:
            already_processed.append('OWNERID')
            self.OWNERID = value
        value = attrs.get('SIZE')
        if value is not None and 'SIZE' not in already_processed:
            already_processed.append('SIZE')
            try:
                self.SIZE = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s'
                                  % exp)
        value = attrs.get('GROUPID')
        if value is not None and 'GROUPID' not in already_processed:
            already_processed.append('GROUPID')
            self.GROUPID = value
        value = attrs.get('BETYPE')
        if value is not None and 'BETYPE' not in already_processed:
            already_processed.append('BETYPE')
            self.BETYPE = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        if nodeName_ == 'FLocat':
            obj_ = FLocat.factory()
            obj_.build(child_)
            self.FLocat.append(obj_)
        elif nodeName_ == 'FContent':
            obj_ = FContent.factory()
            obj_.build(child_)
            self.set_FContent(obj_)
        elif nodeName_ == 'stream':
            obj_ = stream.factory()
            obj_.build(child_)
            self.stream.append(obj_)
        elif nodeName_ == 'transformFile':
            obj_ = transformFile.factory()
            obj_.build(child_)
            self.transformFile.append(obj_)
        elif nodeName_ == 'file':
            obj_ = fileType.factory()
            obj_.build(child_)
            self.file.append(obj_)


# end class fileType


class FLocat(GeneratedsSuper):

    """The file location element <FLocat> provides a pointer to the
    location of a content file. It uses the XLink reference syntax
    to provide linking information indicating the actual location of
    the content file, along with other attributes specifying
    additional linking information. NOTE: <FLocat> is an empty
    element. The location of the resource pointed to MUST be stored
    in the xlink:href attribute. ID (ID/O): This attribute uniquely
    identifies the element within the METS document, and would allow
    the element to be referenced unambiguously from another element
    or document via an IDREF or an XPTR. For more information on
    using ID attributes for internal and external linking see
    Chapter 4 of the METS Primer. USE (string/O): A tagging
    attribute to indicate the intended use of the specific copy of
    the file represented by the <FLocat> element (e.g., service
    master, archive master). A USE attribute can be expressed at
    the<fileGrp> level, the <file> level, the <FLocat> level and/or
    the <FContent> level. A USE attribute value at the <fileGrp>
    level should pertain to all of the files in the <fileGrp>. A USE
    attribute at the <file> level should pertain to all copies of
    the file as represented by subsidiary <FLocat> and/or <FContent>
    elements. A USE attribute at the <FLocat> or <FContent> level
    pertains to the particular copy of the file that is either
    referenced (<FLocat>) or wrapped (<FContent>)."""

    subclass = None
    superclass = None

    def __init__(
        self,
        arcrole=None,
        USE=None,
        title=None,
        OTHERLOCTYPE=None,
        show=None,
        actuate=None,
        href=None,
        role=None,
        LOCTYPE=None,
        type_=None,
        ID=None,
        valueOf_=None,
        ):
        self.arcrole = _cast(None, arcrole)
        self.USE = _cast(None, USE)
        self.title = _cast(None, title)
        self.OTHERLOCTYPE = _cast(None, OTHERLOCTYPE)
        self.show = _cast(None, show)
        self.actuate = _cast(None, actuate)
        self.href = _cast(None, href)
        self.role = _cast(None, role)
        self.LOCTYPE = _cast(None, LOCTYPE)
        self.type_ = _cast(None, type_)
        self.ID = _cast(None, ID)
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if FLocat.subclass:
            return FLocat.subclass(*args_, **kwargs_)
        else:
            return FLocat(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_arcrole(self):
        return self.arcrole

    def set_arcrole(self, arcrole):
        self.arcrole = arcrole

    def get_USE(self):
        return self.USE

    def set_USE(self, USE):
        self.USE = USE

    def get_title(self):
        return self.title

    def set_title(self, title):
        self.title = title

    def get_OTHERLOCTYPE(self):
        return self.OTHERLOCTYPE

    def set_OTHERLOCTYPE(self, OTHERLOCTYPE):
        self.OTHERLOCTYPE = OTHERLOCTYPE

    def get_show(self):
        return self.show

    def set_show(self, show):
        self.show = show

    def get_actuate(self):
        return self.actuate

    def set_actuate(self, actuate):
        self.actuate = actuate

    def get_href(self):
        return self.href

    def set_href(self, href):
        self.href = href

    def get_role(self):
        return self.role

    def set_role(self, role):
        self.role = role

    def get_LOCTYPE(self):
        return self.LOCTYPE

    def set_LOCTYPE(self, LOCTYPE):
        self.LOCTYPE = LOCTYPE

    def get_type(self):
        return self.type_

    def set_type(self, type_):
        self.type_ = type_

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='FLocat',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='FLocat')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='FLocat',
        ):
        if self.arcrole is not None and 'arcrole' \
            not in already_processed:
            already_processed.append('arcrole')
            outfile.write(' arcrole=%s'
                          % (self.gds_format_string(quote_attrib(self.arcrole).encode(ExternalEncoding),
                          input_name='arcrole'), ))
        if self.USE is not None and 'USE' not in already_processed:
            already_processed.append('USE')
            outfile.write(' USE=%s'
                          % (self.gds_format_string(quote_attrib(self.USE).encode(ExternalEncoding),
                          input_name='USE'), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            outfile.write(' title=%s'
                          % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding),
                          input_name='title'), ))
        if self.OTHERLOCTYPE is not None and 'OTHERLOCTYPE' \
            not in already_processed:
            already_processed.append('OTHERLOCTYPE')
            outfile.write(' OTHERLOCTYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.OTHERLOCTYPE).encode(ExternalEncoding),
                          input_name='OTHERLOCTYPE'), ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            outfile.write(' show=%s'
                          % (self.gds_format_string(quote_attrib(self.show).encode(ExternalEncoding),
                          input_name='show'), ))
        if self.actuate is not None and 'actuate' \
            not in already_processed:
            already_processed.append('actuate')
            outfile.write(' actuate=%s'
                          % (self.gds_format_string(quote_attrib(self.actuate).encode(ExternalEncoding),
                          input_name='actuate'), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            outfile.write(' xlink:href=%s'
                          % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding),
                          input_name='href'), ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            outfile.write(' role=%s'
                          % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding),
                          input_name='role'), ))
        if self.LOCTYPE is not None and 'LOCTYPE' \
            not in already_processed:
            already_processed.append('LOCTYPE')
            outfile.write(' LOCTYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.LOCTYPE).encode(ExternalEncoding),
                          input_name='LOCTYPE'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' xlink:type=%s' % (quote_attrib(self.type_), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='FLocat',
        ):
        pass

    def hasContent_(self):
        if self.valueOf_:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='FLocat',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_, ))

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.arcrole is not None and 'arcrole' \
            not in already_processed:
            already_processed.append('arcrole')
            showIndent(outfile, level)
            outfile.write('arcrole = "%s",\n' % (self.arcrole, ))
        if self.USE is not None and 'USE' not in already_processed:
            already_processed.append('USE')
            showIndent(outfile, level)
            outfile.write('USE = "%s",\n' % (self.USE, ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title, ))
        if self.OTHERLOCTYPE is not None and 'OTHERLOCTYPE' \
            not in already_processed:
            already_processed.append('OTHERLOCTYPE')
            showIndent(outfile, level)
            outfile.write('OTHERLOCTYPE = "%s",\n'
                          % (self.OTHERLOCTYPE, ))
        if self.show is not None and 'show' not in already_processed:
            already_processed.append('show')
            showIndent(outfile, level)
            outfile.write('show = "%s",\n' % (self.show, ))
        if self.actuate is not None and 'actuate' \
            not in already_processed:
            already_processed.append('actuate')
            showIndent(outfile, level)
            outfile.write('actuate = "%s",\n' % (self.actuate, ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href, ))
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            showIndent(outfile, level)
            outfile.write('role = "%s",\n' % (self.role, ))
        if self.LOCTYPE is not None and 'LOCTYPE' \
            not in already_processed:
            already_processed.append('LOCTYPE')
            showIndent(outfile, level)
            outfile.write('LOCTYPE = "%s",\n' % (self.LOCTYPE, ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_, ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        pass

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('arcrole')
        if value is not None and 'arcrole' not in already_processed:
            already_processed.append('arcrole')
            self.arcrole = value
        value = attrs.get('USE')
        if value is not None and 'USE' not in already_processed:
            already_processed.append('USE')
            self.USE = value
        value = attrs.get('title')
        if value is not None and 'title' not in already_processed:
            already_processed.append('title')
            self.title = value
        value = attrs.get('OTHERLOCTYPE')
        if value is not None and 'OTHERLOCTYPE' \
            not in already_processed:
            already_processed.append('OTHERLOCTYPE')
            self.OTHERLOCTYPE = value
        value = attrs.get('show')
        if value is not None and 'show' not in already_processed:
            already_processed.append('show')
            self.show = value
        value = attrs.get('actuate')
        if value is not None and 'actuate' not in already_processed:
            already_processed.append('actuate')
            self.actuate = value
        value = attrs.get('href')
        if value is not None and 'href' not in already_processed:
            already_processed.append('href')
            self.href = value
        value = attrs.get('role')
        if value is not None and 'role' not in already_processed:
            already_processed.append('role')
            self.role = value
        value = attrs.get('LOCTYPE')
        if value is not None and 'LOCTYPE' not in already_processed:
            already_processed.append('LOCTYPE')
            self.LOCTYPE = value
        value = attrs.get('type')
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        pass


# end class FLocat


class FContent(GeneratedsSuper):

    """The file content element <FContent> is used to identify a content
    file contained internally within a METS document. The content
    file must be either Base64 encoded and contained within the
    subsidiary <binData> wrapper element, or consist of XML
    information and be contained within the subsidiary <xmlData>
    wrapper element. ID (ID/O): This attribute uniquely identifies
    the element within the METS document, and would allow the
    element to be referenced unambiguously from another element or
    document via an IDREF or an XPTR. For more information on using
    ID attributes for internal and external linking see Chapter 4 of
    the METS Primer. USE (string/O): A tagging attribute to indicate
    the intended use of the specific copy of the file represented by
    the <FContent> element (e.g., service master, archive master). A
    USE attribute can be expressed at the<fileGrp> level, the <file>
    level, the <FLocat> level and/or the <FContent> level. A USE
    attribute value at the <fileGrp> level should pertain to all of
    the files in the <fileGrp>. A USE attribute at the <file> level
    should pertain to all copies of the file as represented by
    subsidiary <FLocat> and/or <FContent> elements. A USE attribute
    at the <FLocat> or <FContent> level pertains to the particular
    copy of the file that is either referenced (<FLocat>) or wrapped
    (<FContent>)."""

    subclass = None
    superclass = None

    def __init__(
        self,
        USE=None,
        ID=None,
        binData=None,
        xmlData=None,
        ):
        self.USE = _cast(None, USE)
        self.ID = _cast(None, ID)
        self.binData = binData
        self.xmlData = xmlData

    def factory(*args_, **kwargs_):
        if FContent.subclass:
            return FContent.subclass(*args_, **kwargs_)
        else:
            return FContent(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_binData(self):
        return self.binData

    def set_binData(self, binData):
        self.binData = binData

    def get_xmlData(self):
        return self.xmlData

    def set_xmlData(self, xmlData):
        self.xmlData = xmlData

    def get_USE(self):
        return self.USE

    def set_USE(self, USE):
        self.USE = USE

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='FContent',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='FContent')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='FContent',
        ):
        if self.USE is not None and 'USE' not in already_processed:
            already_processed.append('USE')
            outfile.write(' USE=%s'
                          % (self.gds_format_string(quote_attrib(self.USE).encode(ExternalEncoding),
                          input_name='USE'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='FContent',
        ):
        if self.binData is not None:
            showIndent(outfile, level)
            outfile.write('<%sbinData>%s</%sbinData>\n' % (namespace_,
                          self.gds_format_string(quote_xml(self.binData).encode(ExternalEncoding),
                          input_name='binData'), namespace_))
        if self.xmlData is not None:
            showIndent(outfile, level)
            outfile.write('<%sxmlData>%s</%sxmlData>\n' % (namespace_,
                          self.gds_format_string(quote_xml(self.xmlData).encode(ExternalEncoding),
                          input_name='xmlData'), namespace_))

    def hasContent_(self):
        if self.binData is not None or self.xmlData is not None:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='FContent',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.USE is not None and 'USE' not in already_processed:
            already_processed.append('USE')
            showIndent(outfile, level)
            outfile.write('USE = "%s",\n' % (self.USE, ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        if self.binData is not None:
            showIndent(outfile, level)
            outfile.write('binData=%s,\n'
                          % quote_python(self.binData).encode(ExternalEncoding))
        if self.xmlData is not None:
            showIndent(outfile, level)
            outfile.write('xmlData=%s,\n'
                          % quote_python(self.xmlData).encode(ExternalEncoding))

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('USE')
        if value is not None and 'USE' not in already_processed:
            already_processed.append('USE')
            self.USE = value
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        if nodeName_ == 'binData':
            binData_ = child_.text
            binData_ = self.gds_validate_string(binData_, node,
                    'binData')
            self.binData = binData_
        elif nodeName_ == 'xmlData':
            xmlData_ = child_.text
            xmlData_ = self.gds_validate_string(xmlData_, node,
                    'xmlData')
            self.xmlData = xmlData_


# end class FContent


class stream(GeneratedsSuper):

    """A component byte stream element <stream> may be composed of one or
    more subsidiary streams. An MPEG4 file, for example, might
    contain separate audio and video streams, each of which is
    associated with technical metadata. The repeatable <stream>
    element provides a mechanism to record the existence of separate
    data streams within a particular file, and the opportunity to
    associate <dmdSec> and <amdSec> with those subsidiary data
    streams if desired. ID (ID/O): This attribute uniquely
    identifies the element within the METS document, and would allow
    the element to be referenced unambiguously from another element
    or document via an IDREF or an XPTR. For more information on
    using ID attributes for internal and external linking see
    Chapter 4 of the METS Primer. streamType (string/O): The IANA
    MIME media type for the bytestream.OWNERID (string/O): Used to
    provide a unique identifier (which could include a URI) assigned
    to the file. This identifier may differ from the URI used to
    retrieve the file. ADMID (IDREFS/O): Contains the ID attribute
    values of the <techMD>, <sourceMD>, <rightsMD> and/or
    <digiprovMD> elements within the <amdSec> of the METS document
    that contain administrative metadata pertaining to the
    bytestream. For more information on using METS IDREFS and IDREF
    type attributes for internal linking, see Chapter 4 of the METS
    Primer. DMDID (IDREFS/O): Contains the ID attribute values
    identifying the <dmdSec>, elements in the METS document that
    contain or link to descriptive metadata pertaining to the
    content file stream represented by the current <stream> element.
    For more information on using METS IDREFS and IDREF type
    attributes for internal linking, see Chapter 4 of the METS
    Primer. BEGIN (string/O): An attribute that specifies the point
    in the parent <file> where the current <stream> begins. It can
    be used in conjunction with the END attribute as a means of
    defining the location of the stream within its parent file.
    However, the BEGIN attribute can be used with or without a
    companion END attribute. When no END attribute is specified, the
    end of the parent file is assumed also to be the end point of
    the stream. The BEGIN and END attributes can only be interpreted
    meaningfully in conjunction with a BETYPE attribute, which
    specifies the kind of beginning/ending point values that are
    being used. END (string/O): An attribute that specifies the
    point in the parent <file> where the <stream> ends. It can only
    be interpreted meaningfully in conjunction with the BETYPE,
    which specifies the kind of ending point values being used.
    Typically the END attribute would only appear in conjunction
    with a BEGIN attribute. BETYPE: Begin/End Type. BETYPE
    (string/O): An attribute that specifies the kind of BEGIN and/or
    END values that are being used. Currently BYTE is the only valid
    value that can be used in conjunction with nested <file> or
    <stream> elements."""

    subclass = None
    superclass = None

    def __init__(
        self,
        BEGIN=None,
        END=None,
        ADMID=None,
        BETYPE=None,
        streamType=None,
        DMDID=None,
        OWNERID=None,
        ID=None,
        valueOf_=None,
        ):
        self.BEGIN = _cast(None, BEGIN)
        self.END = _cast(None, END)
        self.ADMID = _cast(None, ADMID)
        self.BETYPE = _cast(None, BETYPE)
        self.streamType = _cast(None, streamType)
        self.DMDID = _cast(None, DMDID)
        self.OWNERID = _cast(None, OWNERID)
        self.ID = _cast(None, ID)
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if stream.subclass:
            return stream.subclass(*args_, **kwargs_)
        else:
            return stream(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_BEGIN(self):
        return self.BEGIN

    def set_BEGIN(self, BEGIN):
        self.BEGIN = BEGIN

    def get_END(self):
        return self.END

    def set_END(self, END):
        self.END = END

    def get_ADMID(self):
        return self.ADMID

    def set_ADMID(self, ADMID):
        self.ADMID = ADMID

    def get_BETYPE(self):
        return self.BETYPE

    def set_BETYPE(self, BETYPE):
        self.BETYPE = BETYPE

    def get_streamType(self):
        return self.streamType

    def set_streamType(self, streamType):
        self.streamType = streamType

    def get_DMDID(self):
        return self.DMDID

    def set_DMDID(self, DMDID):
        self.DMDID = DMDID

    def get_OWNERID(self):
        return self.OWNERID

    def set_OWNERID(self, OWNERID):
        self.OWNERID = OWNERID

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='stream',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='stream')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='stream',
        ):
        if self.BEGIN is not None and 'BEGIN' not in already_processed:
            already_processed.append('BEGIN')
            outfile.write(' BEGIN=%s'
                          % (self.gds_format_string(quote_attrib(self.BEGIN).encode(ExternalEncoding),
                          input_name='BEGIN'), ))
        if self.END is not None and 'END' not in already_processed:
            already_processed.append('END')
            outfile.write(' END=%s'
                          % (self.gds_format_string(quote_attrib(self.END).encode(ExternalEncoding),
                          input_name='END'), ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            outfile.write(' ADMID=%s'
                          % (self.gds_format_string(quote_attrib(self.ADMID).encode(ExternalEncoding),
                          input_name='ADMID'), ))
        if self.BETYPE is not None and 'BETYPE' \
            not in already_processed:
            already_processed.append('BETYPE')
            outfile.write(' BETYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.BETYPE).encode(ExternalEncoding),
                          input_name='BETYPE'), ))
        if self.streamType is not None and 'streamType' \
            not in already_processed:
            already_processed.append('streamType')
            outfile.write(' streamType=%s'
                          % (self.gds_format_string(quote_attrib(self.streamType).encode(ExternalEncoding),
                          input_name='streamType'), ))
        if self.DMDID is not None and 'DMDID' not in already_processed:
            already_processed.append('DMDID')
            outfile.write(' DMDID=%s'
                          % (self.gds_format_string(quote_attrib(self.DMDID).encode(ExternalEncoding),
                          input_name='DMDID'), ))
        if self.OWNERID is not None and 'OWNERID' \
            not in already_processed:
            already_processed.append('OWNERID')
            outfile.write(' OWNERID=%s'
                          % (self.gds_format_string(quote_attrib(self.OWNERID).encode(ExternalEncoding),
                          input_name='OWNERID'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='stream',
        ):
        pass

    def hasContent_(self):
        if self.valueOf_:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='stream',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_, ))

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.BEGIN is not None and 'BEGIN' not in already_processed:
            already_processed.append('BEGIN')
            showIndent(outfile, level)
            outfile.write('BEGIN = "%s",\n' % (self.BEGIN, ))
        if self.END is not None and 'END' not in already_processed:
            already_processed.append('END')
            showIndent(outfile, level)
            outfile.write('END = "%s",\n' % (self.END, ))
        if self.ADMID is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            showIndent(outfile, level)
            outfile.write('ADMID = "%s",\n' % (self.ADMID, ))
        if self.BETYPE is not None and 'BETYPE' \
            not in already_processed:
            already_processed.append('BETYPE')
            showIndent(outfile, level)
            outfile.write('BETYPE = "%s",\n' % (self.BETYPE, ))
        if self.streamType is not None and 'streamType' \
            not in already_processed:
            already_processed.append('streamType')
            showIndent(outfile, level)
            outfile.write('streamType = "%s",\n' % (self.streamType, ))
        if self.DMDID is not None and 'DMDID' not in already_processed:
            already_processed.append('DMDID')
            showIndent(outfile, level)
            outfile.write('DMDID = "%s",\n' % (self.DMDID, ))
        if self.OWNERID is not None and 'OWNERID' \
            not in already_processed:
            already_processed.append('OWNERID')
            showIndent(outfile, level)
            outfile.write('OWNERID = "%s",\n' % (self.OWNERID, ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        pass

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('BEGIN')
        if value is not None and 'BEGIN' not in already_processed:
            already_processed.append('BEGIN')
            self.BEGIN = value
        value = attrs.get('END')
        if value is not None and 'END' not in already_processed:
            already_processed.append('END')
            self.END = value
        value = attrs.get('ADMID')
        if value is not None and 'ADMID' not in already_processed:
            already_processed.append('ADMID')
            self.ADMID = value
        value = attrs.get('BETYPE')
        if value is not None and 'BETYPE' not in already_processed:
            already_processed.append('BETYPE')
            self.BETYPE = value
        value = attrs.get('streamType')
        if value is not None and 'streamType' not in already_processed:
            already_processed.append('streamType')
            self.streamType = value
        value = attrs.get('DMDID')
        if value is not None and 'DMDID' not in already_processed:
            already_processed.append('DMDID')
            self.DMDID = value
        value = attrs.get('OWNERID')
        if value is not None and 'OWNERID' not in already_processed:
            already_processed.append('OWNERID')
            self.OWNERID = value
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        pass


# end class stream


class transformFile(GeneratedsSuper):

    """The transform file element <transformFile> provides a means to
    access any subsidiary files listed below a <file> element by
    indicating the steps required to "unpack" or transform the
    subsidiary files. This element is repeatable and might provide a
    link to a <behavior> in the <behaviorSec> that performs the
    transformation.ID (ID/O): This attribute uniquely identifies the
    element within the METS document, and would allow the element to
    be referenced unambiguously from another element or document via
    an IDREF or an XPTR. For more information on using ID attributes
    for internal and external linking see Chapter 4 of the METS
    Primer. TRANSFORMTYPE (string/R): Is used to indicate the type
    of transformation needed to render content of a file accessible.
    This may include unpacking a file into subsidiary files/streams.
    The controlled value constraints for this XML string include
    "decompression" and "decryption". Decompression is
    defined as the action of reversing data compression, i.e., the
    process of encoding information using fewer bits than an
    unencoded representation would use by means of specific encoding
    schemas. Decryption is defined as the process of restoring data
    that has been obscured to make it unreadable without special
    knowledge (encrypted data) to its original form. TRANSFORM-
    ALGORITHM (string/R): Specifies the decompression or decryption
    routine used to access the contents of the file. Algorithms for
    compression can be either loss-less or lossy.TRANSFORMKEY
    (string/O): A key to be used with the transform algorithm for
    accessing the file's contents.TRANSFORMBEHAVIOR (string/O): An
    IDREF to a behavior element for this
    transformation.TRANSFORMORDER (postive-integer/R): The order in
    which the instructions must be followed in order to unpack or
    transform the container file."""

    subclass = None
    superclass = None

    def __init__(
        self,
        TRANSFORMTYPE=None,
        TRANSFORMKEY=None,
        TRANSFORMBEHAVIOR=None,
        TRANSFORMALGORITHM=None,
        TRANSFORMORDER=None,
        ID=None,
        valueOf_=None,
        ):
        self.TRANSFORMTYPE = _cast(None, TRANSFORMTYPE)
        self.TRANSFORMKEY = _cast(None, TRANSFORMKEY)
        self.TRANSFORMBEHAVIOR = _cast(None, TRANSFORMBEHAVIOR)
        self.TRANSFORMALGORITHM = _cast(None, TRANSFORMALGORITHM)
        self.TRANSFORMORDER = _cast(int, TRANSFORMORDER)
        self.ID = _cast(None, ID)
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if transformFile.subclass:
            return transformFile.subclass(*args_, **kwargs_)
        else:
            return transformFile(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_TRANSFORMTYPE(self):
        return self.TRANSFORMTYPE

    def set_TRANSFORMTYPE(self, TRANSFORMTYPE):
        self.TRANSFORMTYPE = TRANSFORMTYPE

    def get_TRANSFORMKEY(self):
        return self.TRANSFORMKEY

    def set_TRANSFORMKEY(self, TRANSFORMKEY):
        self.TRANSFORMKEY = TRANSFORMKEY

    def get_TRANSFORMBEHAVIOR(self):
        return self.TRANSFORMBEHAVIOR

    def set_TRANSFORMBEHAVIOR(self, TRANSFORMBEHAVIOR):
        self.TRANSFORMBEHAVIOR = TRANSFORMBEHAVIOR

    def get_TRANSFORMALGORITHM(self):
        return self.TRANSFORMALGORITHM

    def set_TRANSFORMALGORITHM(self, TRANSFORMALGORITHM):
        self.TRANSFORMALGORITHM = TRANSFORMALGORITHM

    def get_TRANSFORMORDER(self):
        return self.TRANSFORMORDER

    def set_TRANSFORMORDER(self, TRANSFORMORDER):
        self.TRANSFORMORDER = TRANSFORMORDER

    def get_ID(self):
        return self.ID

    def set_ID(self, ID):
        self.ID = ID

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='transformFile',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='transformFile')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='transformFile',
        ):
        if self.TRANSFORMTYPE is not None and 'TRANSFORMTYPE' \
            not in already_processed:
            already_processed.append('TRANSFORMTYPE')
            outfile.write(' TRANSFORMTYPE=%s'
                          % (self.gds_format_string(quote_attrib(self.TRANSFORMTYPE).encode(ExternalEncoding),
                          input_name='TRANSFORMTYPE'), ))
        if self.TRANSFORMKEY is not None and 'TRANSFORMKEY' \
            not in already_processed:
            already_processed.append('TRANSFORMKEY')
            outfile.write(' TRANSFORMKEY=%s'
                          % (self.gds_format_string(quote_attrib(self.TRANSFORMKEY).encode(ExternalEncoding),
                          input_name='TRANSFORMKEY'), ))
        if self.TRANSFORMBEHAVIOR is not None and 'TRANSFORMBEHAVIOR' \
            not in already_processed:
            already_processed.append('TRANSFORMBEHAVIOR')
            outfile.write(' TRANSFORMBEHAVIOR=%s'
                          % (self.gds_format_string(quote_attrib(self.TRANSFORMBEHAVIOR).encode(ExternalEncoding),
                          input_name='TRANSFORMBEHAVIOR'), ))
        if self.TRANSFORMALGORITHM is not None and 'TRANSFORMALGORITHM' \
            not in already_processed:
            already_processed.append('TRANSFORMALGORITHM')
            outfile.write(' TRANSFORMALGORITHM=%s'
                          % (self.gds_format_string(quote_attrib(self.TRANSFORMALGORITHM).encode(ExternalEncoding),
                          input_name='TRANSFORMALGORITHM'), ))
        if self.TRANSFORMORDER is not None and 'TRANSFORMORDER' \
            not in already_processed:
            already_processed.append('TRANSFORMORDER')
            outfile.write(' TRANSFORMORDER="%s"'
                          % self.gds_format_integer(self.TRANSFORMORDER,
                          input_name='TRANSFORMORDER'))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s'
                          % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding),
                          input_name='ID'), ))

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='transformFile',
        ):
        pass

    def hasContent_(self):
        if self.valueOf_:
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='transformFile',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_, ))

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        if self.TRANSFORMTYPE is not None and 'TRANSFORMTYPE' \
            not in already_processed:
            already_processed.append('TRANSFORMTYPE')
            showIndent(outfile, level)
            outfile.write('TRANSFORMTYPE = "%s",\n'
                          % (self.TRANSFORMTYPE, ))
        if self.TRANSFORMKEY is not None and 'TRANSFORMKEY' \
            not in already_processed:
            already_processed.append('TRANSFORMKEY')
            showIndent(outfile, level)
            outfile.write('TRANSFORMKEY = "%s",\n'
                          % (self.TRANSFORMKEY, ))
        if self.TRANSFORMBEHAVIOR is not None and 'TRANSFORMBEHAVIOR' \
            not in already_processed:
            already_processed.append('TRANSFORMBEHAVIOR')
            showIndent(outfile, level)
            outfile.write('TRANSFORMBEHAVIOR = "%s",\n'
                          % (self.TRANSFORMBEHAVIOR, ))
        if self.TRANSFORMALGORITHM is not None and 'TRANSFORMALGORITHM' \
            not in already_processed:
            already_processed.append('TRANSFORMALGORITHM')
            showIndent(outfile, level)
            outfile.write('TRANSFORMALGORITHM = "%s",\n'
                          % (self.TRANSFORMALGORITHM, ))
        if self.TRANSFORMORDER is not None and 'TRANSFORMORDER' \
            not in already_processed:
            already_processed.append('TRANSFORMORDER')
            showIndent(outfile, level)
            outfile.write('TRANSFORMORDER = %d,\n'
                          % (self.TRANSFORMORDER, ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID, ))

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        pass

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        value = attrs.get('TRANSFORMTYPE')
        if value is not None and 'TRANSFORMTYPE' \
            not in already_processed:
            already_processed.append('TRANSFORMTYPE')
            self.TRANSFORMTYPE = value
        value = attrs.get('TRANSFORMKEY')
        if value is not None and 'TRANSFORMKEY' \
            not in already_processed:
            already_processed.append('TRANSFORMKEY')
            self.TRANSFORMKEY = value
        value = attrs.get('TRANSFORMBEHAVIOR')
        if value is not None and 'TRANSFORMBEHAVIOR' \
            not in already_processed:
            already_processed.append('TRANSFORMBEHAVIOR')
            self.TRANSFORMBEHAVIOR = value
        value = attrs.get('TRANSFORMALGORITHM')
        if value is not None and 'TRANSFORMALGORITHM' \
            not in already_processed:
            already_processed.append('TRANSFORMALGORITHM')
            self.TRANSFORMALGORITHM = value
        value = attrs.get('TRANSFORMORDER')
        if value is not None and 'TRANSFORMORDER' \
            not in already_processed:
            already_processed.append('TRANSFORMORDER')
            try:
                self.TRANSFORMORDER = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s'
                                  % exp)
            if self.TRANSFORMORDER <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = attrs.get('ID')
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        pass


# end class transformFile


class structLink(structLinkType):

    """The structural link section element <structLink> allows for the
    specification of hyperlinks between the different components of
    a METS structure that are delineated in a structural map. This
    element is a container for a single, repeatable element,
    <smLink> which indicates a hyperlink between two nodes in the
    structural map. The <structLink> section in the METS document is
    identified using its XML ID attributes."""

    subclass = None
    superclass = structLinkType

    def __init__(
        self,
        ID=None,
        smLink=None,
        smLinkGrp=None,
        ):
        super(structLink, self).__init__(ID, smLink, smLinkGrp)
        pass

    def factory(*args_, **kwargs_):
        if structLink.subclass:
            return structLink.subclass(*args_, **kwargs_)
        else:
            return structLink(*args_, **kwargs_)

    factory = staticmethod(factory)

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='structLink',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='structLink')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"'
                      )
        outfile.write(' xsi:type="structLink"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='structLink',
        ):
        super(structLink, self).exportAttributes(outfile, level,
                already_processed, namespace_, name_='structLink')

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='structLink',
        ):
        super(structLink, self).exportChildren(outfile, level,
                namespace_, name_)

    def hasContent_(self):
        if super(structLink, self).hasContent_():
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='structLink',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        super(structLink, self).exportLiteralAttributes(outfile, level,
                already_processed, name_)

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        super(structLink, self).exportLiteralChildren(outfile, level,
                name_)

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        super(structLink, self).buildAttributes(node, attrs,
                already_processed)

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        super(structLink, self).buildChildren(child_, node, nodeName_,
                True)
        pass


# end class structLink


class fileGrp(fileGrpType):

    """A sequence of file group elements <fileGrp> can be used group the
    digital files comprising the content of a METS object either
    into a flat arrangement or, because each file group element can
    itself contain one or more file group elements, into a nested
    (hierarchical) arrangement. In the case where the content files
    are images of different formats and resolutions, for example,
    one could group the image content files by format and create a
    separate <fileGrp> for each image format/resolution such as: --
    one <fileGrp> for the thumbnails of the images -- one <fileGrp>
    for the higher resolution JPEGs of the image -- one <fileGrp>
    for the master archival TIFFs of the images For a text resource
    with a variety of content file types one might group the content
    files at the highest level by type, and then use the <fileGrp>
    element's nesting capabilities to subdivide a <fileGrp> by
    format within the type, such as: -- one <fileGrp> for all of the
    page images with nested <fileGrp> elements for each image
    format/resolution (tiff, jpeg, gif) -- one <fileGrp> for a PDF
    version of all the pages of the document -- one <fileGrp> for a
    TEI encoded XML version of the entire document or each of its
    pages. A <fileGrp> may contain zero or more <fileGrp> elements
    and or <file> elements."""

    subclass = None
    superclass = fileGrpType

    def __init__(
        self,
        VERSDATE=None,
        ADMID=None,
        ID=None,
        USE=None,
        fileGrp=None,
        file=None,
        ):
        super(fileGrp, self).__init__(
            VERSDATE,
            ADMID,
            ID,
            USE,
            fileGrp,
            file,
            )
        pass

    def factory(*args_, **kwargs_):
        if fileGrp.subclass:
            return fileGrp.subclass(*args_, **kwargs_)
        else:
            return fileGrp(*args_, **kwargs_)

    factory = staticmethod(factory)

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='fileGrp',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='fileGrp')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"'
                      )
        outfile.write(' xsi:type="fileGrp"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='fileGrp',
        ):
        super(fileGrp, self).exportAttributes(outfile, level,
                already_processed, namespace_, name_='fileGrp')

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='fileGrp',
        ):
        super(fileGrp, self).exportChildren(outfile, level, namespace_,
                name_)

    def hasContent_(self):
        if super(fileGrp, self).hasContent_():
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='fileGrp',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        super(fileGrp, self).exportLiteralAttributes(outfile, level,
                already_processed, name_)

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        super(fileGrp, self).exportLiteralChildren(outfile, level,
                name_)

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        super(fileGrp, self).buildAttributes(node, attrs,
                already_processed)

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        super(fileGrp, self).buildChildren(child_, node, nodeName_,
                True)
        pass


# end class fileGrp


class mets(metsType):

    """METS: Metadata Encoding and Transmission Standard. METS is intended
    to provide a standardized XML format for transmission of complex
    digital library objects between systems. As such, it can be seen
    as filling a role similar to that defined for the Submission
    Information Package (SIP), Archival Information Package (AIP)
    and Dissemination Information Package (DIP) in the Reference
    Model for an Open Archival Information System. The root element
    <mets> establishes the container for the information being
    stored and/or transmitted by the standard."""

    subclass = None
    superclass = metsType

    def __init__(
        self,
        PROFILE=None,
        LABEL=None,
        TYPE=None,
        ID=None,
        OBJID=None,
        metsHdr=None,
        dmdSec=None,
        amdSec=None,
        fileSec=None,
        structMap=None,
        structLink=None,
        behaviorSec=None,
        ):
        super(mets, self).__init__(
            PROFILE,
            LABEL,
            TYPE,
            ID,
            OBJID,
            metsHdr,
            dmdSec,
            amdSec,
            fileSec,
            structMap,
            structLink,
            behaviorSec,
            )
        pass

    def factory(*args_, **kwargs_):
        if mets.subclass:
            return mets.subclass(*args_, **kwargs_)
        else:
            return mets(*args_, **kwargs_)

    factory = staticmethod(factory)

    def export(
        self,
        outfile,
        level,
        namespace_='',
        name_='mets',
        namespacedef_='',
        ):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_
                      and ' ' + namespacedef_ or ''))
        self.exportAttributes(outfile, level, [], namespace_,
                              name_='mets')
        outfile.write(' xsi:type="mets"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')

    def exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespace_='',
        name_='mets',
        ):
        super(mets, self).exportAttributes(outfile, level,
                already_processed, namespace_, name_='mets')

    def exportChildren(
        self,
        outfile,
        level,
        namespace_='',
        name_='mets',
        ):
        super(mets, self).exportChildren(outfile, level, namespace_,
                name_)

    def hasContent_(self):
        if super(mets, self).hasContent_():
            return True
        else:
            return False

    def exportLiteral(
        self,
        outfile,
        level,
        name_='mets',
        ):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)

    def exportLiteralAttributes(
        self,
        outfile,
        level,
        already_processed,
        name_,
        ):
        super(mets, self).exportLiteralAttributes(outfile, level,
                already_processed, name_)

    def exportLiteralChildren(
        self,
        outfile,
        level,
        name_,
        ):
        super(mets, self).exportLiteralChildren(outfile, level, name_)

    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)

    def buildAttributes(
        self,
        node,
        attrs,
        already_processed,
        ):
        super(mets, self).buildAttributes(node, attrs,
                already_processed)

    def buildChildren(
        self,
        child_,
        node,
        nodeName_,
        from_subclass=False,
        ):
        super(mets, self).buildChildren(child_, node, nodeName_, True)
        pass


# end class mets

USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return (tag, rootClass)


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    (rootTag, rootClass) = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'mets'
        rootClass = mets
    rootObj = rootClass.factory()
    rootObj.build(rootNode)

    # Enable Python to collect the space used by the DOM.

    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag, namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    (rootTag, rootClass) = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'mets'
        rootClass = mets
    rootObj = rootClass.factory()
    rootObj.build(rootNode)

    # Enable Python to collect the space used by the DOM.

    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_='mets', namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    (rootTag, rootClass) = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'mets'
        rootClass = mets
    rootObj = rootClass.factory()
    rootObj.build(rootNode)

    # Enable Python to collect the space used by the DOM.

    doc = None
    sys.stdout.write('''#from mets import *

''')
    sys.stdout.write('''import mets as model_

''')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def prettify(level, elem):
    """Return a pretty-printed XML string for the Element.
    """

    rough_string = ElementTree.tostring(elem, 'utf-8')
    reparsed = minidom.parseString(rough_string)
    return reparsed.toprettyxml(indent='    ')


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':

    # import pdb; pdb.set_trace()

    main()

__all__ = [
    'FContent',
    'FLocat',
    'agent',
    'altRecordID',
    'amdSecType',
    'areaType',
    'behaviorSecType',
    'behaviorType',
    'divType',
    'fileGrp',
    'fileGrpType',
    'fileSec',
    'fileType',
    'fptr',
    'mdRef',
    'mdSecType',
    'mdWrap',
    'mets',
    'metsDocumentID',
    'metsHdr',
    'metsType',
    'mptr',
    'objectType',
    'parType',
    'seqType',
    'smArcLink',
    'smLink',
    'smLinkGrp',
    'smLocatorLink',
    'stream',
    'structLink',
    'structLinkType',
    'structMapType',
    'transformFile',
    'xmlData',
    ]
