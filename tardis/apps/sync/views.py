# -*- coding: utf-8 -*-
#
# Copyright (c) 2010-2012, Monash e-Research Centre
#   (Monash University, Australia)
# Copyright (c) 2010-2012, VeRSI Consortium
#   (Victorian eResearch Strategic Initiative, Australia)
# All rights reserved.
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#    *  Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#    *  Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#    *  Neither the name of the VeRSI, the VeRSI Consortium members, nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
"""
views.py

.. moduleauthor:: Kieran Spear <kispear@gmail.com>
.. moduleauthor:: Shaun O'Keefe <shaun.okeefe.0@gmail.com>

"""
import logging
import json

from django.http import HttpResponse
from django.template import Context
from django.shortcuts import render_to_response
from django.conf import settings
from django.views.decorators.cache import never_cache
from django.contrib.auth.decorators import user_passes_test

from tardis.tardis_portal.shortcuts import render_response_index
from tardis.tardis_portal.auth import decorators as authz

from tardis.apps.sync.models import SyncedExperiment
from tardis.apps.sync.forms import FileTransferRequestForm

from transfer_service import TransferService

logger = logging.getLogger('tardis.mecat')


def client_key_required(f):
    def wrap(request, *args, **kwargs):
        # Temporary until more flexible auth is implemented.
        key = request.META.get('HTTP_X_MYTARDIS_KEY', '')
        addr = request.META['REMOTE_ADDR']
        if not request.is_secure() and not getattr(settings, 'SYNC_INSECURE', False):
            return HttpResponse('Use HTTPS', mimetype='application/json', status=404)
        if not key or (addr, key) not in settings.SYNC_CLIENT_KEYS:
            logger.warning("Sync: %s sent invalid key." % addr)
            return HttpResponse('', mimetype='application/json', status=403)
        return f(request, *args, **kwargs)
    wrap.__doc__ = f.__doc__
    wrap.__name__ = f.__name__
    return wrap

# provider api
@client_key_required
@never_cache
def get_experiment(request):
    """ Request that an experiment be transferred from the provider
        to the consumer

    :param uid: a unique of the experiment generated by the  provider
    :rtype :class:'django.https.HttpResponse'
    """
    if request.method == 'POST':

        form = FileTransferRequestForm(request.POST)
        if not form.is_valid():
            return HttpResponse('ERROR', status=400)

        return handle_file_transfer_request(form)

    else:
        form = FileTransferRequestForm()

    c = Context({'header': 'Register File Transfer Request',
                 'form': form})
    return render_to_response('tardis_portal/form_template.html', c)


def handle_file_transfer_request(form):
    site_settings_url = form.cleaned_data['site_settings_url']
    # remote experiment id
    uid = form.cleaned_data['uid']
    # path to copy data to
    dest_path = form.cleaned_data['dest_path']

    logger.info('File transfer request received: %s -> %s at %s' % (uid, dest_path, site_settings_url))

    ts = TransferService()
    try:
        ts.start_file_transfer(uid, site_settings_url, dest_path)
    except TransferService.TransferError as detail:
        return HttpResponse('Transfer error for experiment %s: %s' % (uid, detail))
    except TransferService.InvalidUIDError:
        return HttpResponse('Transfer error: Experiment UID does not exist.', status=404)
    return HttpResponse('OK', status=200)


@client_key_required
@never_cache
def transfer_status(request, uid):
    """Request information about the status of the transfer of 
       an experiment.

    :param uid: a unique id of the experiment generated by the  provider
    :rtype :class:'django.https.HttpResponse'
    """
    ts = TransferService()
    try:
        json_dict = ts.get_status(uid)
    except TransferService.InvalidUIDError as detail:
        json_dict = { 'status': TransferService.TRANSFER_BAD_REQUEST,
                      'error': 'invalid UID: %s' % detail, }
    response = HttpResponse(json.dumps(json_dict), mimetype='application/json')
    return response


# consumer api

# At the moment this code remains in the core tardis. A signal is used to
# get notification that an experiment has been received from an upstream
# tardis and ingested. At that point the Experiment already exists,
# so we currently just create a SyncedExperiment row to track it.

def notify_experiment(request, uid):
    
    """Recive notification that an experiment has been ingested.

    :param uid: a unique id of the experiment generated by the provider
    :rtype :class:'django.https.HttpResponse'
    """
    # TODO
    exp = SyncedExperiment(uid=uid)
    exp.save()

@never_cache
@authz.experiment_access_required
def index(request, experiment_id):
    synced_exp = None
    try:
        synced_exp = SyncedExperiment.objects.get(experiment__pk=experiment_id)
    except SyncedExperiment.DoesNotExist:
        pass
    message = {}
    if synced_exp:
        if synced_exp.msg:
            try:
                message = json.loads(synced_exp.msg)
            except:
                pass
    c = Context({'object': synced_exp, 'message':message, 'admins':settings.SYNC_ADMINS})
    url = 'sync/syncedexperiment_detail.html'
    return HttpResponse(render_response_index(request, url, c))


@user_passes_test(lambda u: u.is_staff)
def integrity(request, experiment_id):
    from .integrity import IntegrityCheck
    ic = IntegrityCheck(experiment_id)
    if ic is not None:
        dfi = ic.get_datafiles_integrity()
        dfi['experiment_id'] = experiment_id
        c = Context(dfi)
        return HttpResponse(render_response_index(request, 'sync/integrity.html', c))
    return return_response_not_found(request)

